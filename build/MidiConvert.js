(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["MidiConvert"] = factory();
	else
		root["MidiConvert"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _Midi = __webpack_require__(1);\n\nvar MidiConvert = {\n\t/**\n  *  Parse all the data from the Midi file into this format:\n  *  {\n  *  \t// the transport and timing data\n  *  \theader : {\n  *  \t\tbpm : Number,                     // tempo, e.g. 120\n  *  \t\ttimeSignature : [Number, Number], // time signature, e.g. [4, 4],\n  *  \t\tPPQ : Number                  // PPQ of the midi file\n  *  \t},\n  *  \t// an array for each of the midi tracks\n  *  \ttracks : [\n  *  \t\t{\n  *  \t\t\tname : String, // the track name if one was given\n  *  \t\t\tnotes : [\n  *  \t\t\t\t{\n  *  \t\t\t\t\ttime : Number, // time in seconds\n  *  \t\t\t\t\tname : String, // note name, e.g. 'C4'\n  *  \t\t\t\t\tmidi : Number, // midi number, e.g. 60\n  *  \t\t\t\t\tvelocity : Number,  // normalized velocity\n  *  \t\t\t\t\tduration : Number   // duration between noteOn and noteOff\n  *  \t\t\t\t}\n  *  \t\t\t],\n  *  \t\t\tcontrolChanges : { //all of the control changes\n  *  \t\t\t\t64 : [ //array for each cc value\n  *  \t\t\t\t\t{\n  *  \t\t\t\t\t\tnumber : Number, //the cc number\n  *  \t\t\t\t\t\ttime : Number, //the time of the event in seconds\n  *  \t\t\t\t\t\tname : String, // if the cc value has a common name (e.g. 'sustain')\n  *  \t\t\t\t\t\tvalue : Number, //the normalized value\n  *  \t\t\t\t\t}\n  *  \t\t\t\t]\n  *  \t\t\t}\n  *  \t\t}\n  *  \t]\n  *  }\n  *  @param  {Binary String}  fileBlob  The output from fs.readFile or FileReader\n  *  @returns {Object} All of the options parsed from the midi file. \n  */\n\tparse: function parse(fileBlob) {\n\t\treturn new _Midi.Midi().decode(fileBlob);\n\t},\n\t/**\n  *  Load and parse a midi file. See `parse` for what the results look like.\n  *  @param  {String}    url\n  *  @param {Function=} callback\n  *  @returns {Promise} A promise which is invoked with the returned Midi object\n  */\n\tload: function load(url, callback) {\n\t\tvar promise = new _Midi.Midi().load(url);\n\t\tif (callback) {\n\t\t\tpromise.then(callback);\n\t\t}\n\t\treturn promise;\n\t},\n\t/**\n  * Create an empty midi file\n  * @return {Midi}\n  */\n\tcreate: function create() {\n\t\treturn new _Midi.Midi();\n\t}\n};\n\nexports.default = MidiConvert;\n\n\nmodule.exports = MidiConvert;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvTWlkaUNvbnZlcnQuanM/NWVhYiJdLCJuYW1lcyI6WyJNaWRpQ29udmVydCIsInBhcnNlIiwiZmlsZUJsb2IiLCJkZWNvZGUiLCJsb2FkIiwidXJsIiwiY2FsbGJhY2siLCJwcm9taXNlIiwidGhlbiIsImNyZWF0ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUVBLElBQU1BLGNBQWM7QUFDbkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0NBQyxRQUFRLGVBQVNDLFFBQVQsRUFBa0I7QUFDekIsU0FBTyxpQkFBV0MsTUFBWCxDQUFrQkQsUUFBbEIsQ0FBUDtBQUNBLEVBekNrQjtBQTBDbkI7Ozs7OztBQU1BRSxPQUFPLGNBQVNDLEdBQVQsRUFBY0MsUUFBZCxFQUF1QjtBQUM3QixNQUFNQyxVQUFVLGlCQUFXSCxJQUFYLENBQWdCQyxHQUFoQixDQUFoQjtBQUNBLE1BQUlDLFFBQUosRUFBYTtBQUNaQyxXQUFRQyxJQUFSLENBQWFGLFFBQWI7QUFDQTtBQUNELFNBQU9DLE9BQVA7QUFDQSxFQXREa0I7QUF1RG5COzs7O0FBSUFFLFNBQVMsa0JBQVU7QUFDbEIsU0FBTyxnQkFBUDtBQUNBO0FBN0RrQixDQUFwQjs7a0JBZ0VlVCxXOzs7QUFFZlUsT0FBT0MsT0FBUCxHQUFpQlgsV0FBakIiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TWlkaX0gZnJvbSAnLi9NaWRpJ1xuXG5jb25zdCBNaWRpQ29udmVydCA9IHtcblx0LyoqXG5cdCAqICBQYXJzZSBhbGwgdGhlIGRhdGEgZnJvbSB0aGUgTWlkaSBmaWxlIGludG8gdGhpcyBmb3JtYXQ6XG5cdCAqICB7XG5cdCAqICBcdC8vIHRoZSB0cmFuc3BvcnQgYW5kIHRpbWluZyBkYXRhXG5cdCAqICBcdGhlYWRlciA6IHtcblx0ICogIFx0XHRicG0gOiBOdW1iZXIsICAgICAgICAgICAgICAgICAgICAgLy8gdGVtcG8sIGUuZy4gMTIwXG5cdCAqICBcdFx0dGltZVNpZ25hdHVyZSA6IFtOdW1iZXIsIE51bWJlcl0sIC8vIHRpbWUgc2lnbmF0dXJlLCBlLmcuIFs0LCA0XSxcblx0ICogIFx0XHRQUFEgOiBOdW1iZXIgICAgICAgICAgICAgICAgICAvLyBQUFEgb2YgdGhlIG1pZGkgZmlsZVxuXHQgKiAgXHR9LFxuXHQgKiAgXHQvLyBhbiBhcnJheSBmb3IgZWFjaCBvZiB0aGUgbWlkaSB0cmFja3Ncblx0ICogIFx0dHJhY2tzIDogW1xuXHQgKiAgXHRcdHtcblx0ICogIFx0XHRcdG5hbWUgOiBTdHJpbmcsIC8vIHRoZSB0cmFjayBuYW1lIGlmIG9uZSB3YXMgZ2l2ZW5cblx0ICogIFx0XHRcdG5vdGVzIDogW1xuXHQgKiAgXHRcdFx0XHR7XG5cdCAqICBcdFx0XHRcdFx0dGltZSA6IE51bWJlciwgLy8gdGltZSBpbiBzZWNvbmRzXG5cdCAqICBcdFx0XHRcdFx0bmFtZSA6IFN0cmluZywgLy8gbm90ZSBuYW1lLCBlLmcuICdDNCdcblx0ICogIFx0XHRcdFx0XHRtaWRpIDogTnVtYmVyLCAvLyBtaWRpIG51bWJlciwgZS5nLiA2MFxuXHQgKiAgXHRcdFx0XHRcdHZlbG9jaXR5IDogTnVtYmVyLCAgLy8gbm9ybWFsaXplZCB2ZWxvY2l0eVxuXHQgKiAgXHRcdFx0XHRcdGR1cmF0aW9uIDogTnVtYmVyICAgLy8gZHVyYXRpb24gYmV0d2VlbiBub3RlT24gYW5kIG5vdGVPZmZcblx0ICogIFx0XHRcdFx0fVxuXHQgKiAgXHRcdFx0XSxcblx0ICogIFx0XHRcdGNvbnRyb2xDaGFuZ2VzIDogeyAvL2FsbCBvZiB0aGUgY29udHJvbCBjaGFuZ2VzXG5cdCAqICBcdFx0XHRcdDY0IDogWyAvL2FycmF5IGZvciBlYWNoIGNjIHZhbHVlXG5cdCAqICBcdFx0XHRcdFx0e1xuXHQgKiAgXHRcdFx0XHRcdFx0bnVtYmVyIDogTnVtYmVyLCAvL3RoZSBjYyBudW1iZXJcblx0ICogIFx0XHRcdFx0XHRcdHRpbWUgOiBOdW1iZXIsIC8vdGhlIHRpbWUgb2YgdGhlIGV2ZW50IGluIHNlY29uZHNcblx0ICogIFx0XHRcdFx0XHRcdG5hbWUgOiBTdHJpbmcsIC8vIGlmIHRoZSBjYyB2YWx1ZSBoYXMgYSBjb21tb24gbmFtZSAoZS5nLiAnc3VzdGFpbicpXG5cdCAqICBcdFx0XHRcdFx0XHR2YWx1ZSA6IE51bWJlciwgLy90aGUgbm9ybWFsaXplZCB2YWx1ZVxuXHQgKiAgXHRcdFx0XHRcdH1cblx0ICogIFx0XHRcdFx0XVxuXHQgKiAgXHRcdFx0fVxuXHQgKiAgXHRcdH1cblx0ICogIFx0XVxuXHQgKiAgfVxuXHQgKiAgQHBhcmFtICB7QmluYXJ5IFN0cmluZ30gIGZpbGVCbG9iICBUaGUgb3V0cHV0IGZyb20gZnMucmVhZEZpbGUgb3IgRmlsZVJlYWRlclxuXHQgKiAgQHJldHVybnMge09iamVjdH0gQWxsIG9mIHRoZSBvcHRpb25zIHBhcnNlZCBmcm9tIHRoZSBtaWRpIGZpbGUuIFxuXHQgKi9cblx0cGFyc2UgOiBmdW5jdGlvbihmaWxlQmxvYil7XG5cdFx0cmV0dXJuIG5ldyBNaWRpKCkuZGVjb2RlKGZpbGVCbG9iKVxuXHR9LFxuXHQvKipcblx0ICogIExvYWQgYW5kIHBhcnNlIGEgbWlkaSBmaWxlLiBTZWUgYHBhcnNlYCBmb3Igd2hhdCB0aGUgcmVzdWx0cyBsb29rIGxpa2UuXG5cdCAqICBAcGFyYW0gIHtTdHJpbmd9ICAgIHVybFxuXHQgKiAgQHBhcmFtIHtGdW5jdGlvbj19IGNhbGxiYWNrXG5cdCAqICBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIHdoaWNoIGlzIGludm9rZWQgd2l0aCB0aGUgcmV0dXJuZWQgTWlkaSBvYmplY3Rcblx0ICovXG5cdGxvYWQgOiBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKXtcblx0XHRjb25zdCBwcm9taXNlID0gbmV3IE1pZGkoKS5sb2FkKHVybClcblx0XHRpZiAoY2FsbGJhY2spe1xuXHRcdFx0cHJvbWlzZS50aGVuKGNhbGxiYWNrKVxuXHRcdH1cblx0XHRyZXR1cm4gcHJvbWlzZVxuXHR9LFxuXHQvKipcblx0ICogQ3JlYXRlIGFuIGVtcHR5IG1pZGkgZmlsZVxuXHQgKiBAcmV0dXJuIHtNaWRpfVxuXHQgKi9cblx0Y3JlYXRlIDogZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gbmV3IE1pZGkoKVxuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1pZGlDb252ZXJ0XG5cbm1vZHVsZS5leHBvcnRzID0gTWlkaUNvbnZlcnRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9NaWRpQ29udmVydC5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.Midi = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _midiFileParser = __webpack_require__(2);\n\nvar _midiFileParser2 = _interopRequireDefault(_midiFileParser);\n\nvar _jsmidgen = __webpack_require__(3);\n\nvar _jsmidgen2 = _interopRequireDefault(_jsmidgen);\n\nvar _Util = __webpack_require__(5);\n\nvar _Util2 = _interopRequireDefault(_Util);\n\nvar _Track = __webpack_require__(6);\n\nvar _Header = __webpack_require__(11);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @class The Midi object. Contains tracks and the header info.\n */\nvar Midi = function () {\n\tfunction Midi() {\n\t\t_classCallCheck(this, Midi);\n\n\t\tthis.header = {\n\t\t\t//defaults\n\t\t\tbpm: 120,\n\t\t\ttimeSignature: [4, 4],\n\t\t\tPPQ: 480\n\t\t};\n\n\t\tthis.tracks = [];\n\t}\n\n\t/**\n  * Load the given url and parse the midi at that url\n  * @param  {String}   url  \n  * @param {*} data Anything that should be sent in the XHR\n  * @param {String} method Either GET or POST    \n  * @return {Promise}            \n  */\n\n\n\t_createClass(Midi, [{\n\t\tkey: 'load',\n\t\tvalue: function load(url) {\n\t\t\tvar _this = this;\n\n\t\t\tvar data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\t\tvar method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'GET';\n\n\t\t\treturn new Promise(function (success, fail) {\n\t\t\t\tvar request = new XMLHttpRequest();\n\t\t\t\trequest.open(method, url);\n\t\t\t\trequest.responseType = 'arraybuffer';\n\t\t\t\t// decode asynchronously\n\t\t\t\trequest.addEventListener('load', function () {\n\t\t\t\t\tif (request.readyState === 4 && request.status === 200) {\n\t\t\t\t\t\tsuccess(_this.decode(request.response));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfail(request.status);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\trequest.addEventListener('error', fail);\n\t\t\t\trequest.send(data);\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * Decode the bytes\n   * @param  {String|ArrayBuffer} bytes The midi file encoded as a string or ArrayBuffer\n   * @return {Midi}       this\n   */\n\n\t}, {\n\t\tkey: 'decode',\n\t\tvalue: function decode(bytes) {\n\t\t\tvar _this2 = this;\n\n\t\t\tif (bytes instanceof ArrayBuffer) {\n\t\t\t\tvar byteArray = new Uint8Array(bytes);\n\t\t\t\tbytes = String.fromCharCode.apply(null, byteArray);\n\t\t\t}\n\n\t\t\tvar midiData = (0, _midiFileParser2.default)(bytes);\n\n\t\t\tthis.header = (0, _Header.parseHeader)(midiData);\n\n\t\t\t//replace the previous tracks\n\t\t\tthis.tracks = [];\n\n\t\t\tmidiData.tracks.forEach(function (trackData) {\n\n\t\t\t\tvar track = new _Track.Track();\n\t\t\t\t_this2.tracks.push(track);\n\n\t\t\t\tvar absoluteTime = 0;\n\t\t\t\ttrackData.forEach(function (event) {\n\t\t\t\t\tabsoluteTime += _Util2.default.ticksToSeconds(event.deltaTime, _this2.header);\n\t\t\t\t\tif (event.type === 'meta' && event.subtype === 'trackName') {\n\t\t\t\t\t\ttrack.name = _Util2.default.cleanName(event.text);\n\t\t\t\t\t} else if (event.subtype === 'noteOn') {\n\t\t\t\t\t\ttrack.noteOn(event.noteNumber, absoluteTime, event.velocity / 127);\n\t\t\t\t\t} else if (event.subtype === 'noteOff') {\n\t\t\t\t\t\ttrack.noteOff(event.noteNumber, absoluteTime);\n\t\t\t\t\t} else if (event.subtype === 'controller' && event.controllerType) {\n\t\t\t\t\t\ttrack.cc(event.controllerType, absoluteTime, event.value / 127);\n\t\t\t\t\t} else if (event.type === 'meta' && event.subtype === 'instrumentName') {\n\t\t\t\t\t\ttrack.instrument = event.text;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n   * Encode the Midi object as a Buffer String\n   * @returns {String}\n   */\n\n\t}, {\n\t\tkey: 'encode',\n\t\tvalue: function encode() {\n\t\t\tvar _this3 = this;\n\n\t\t\tvar output = new _jsmidgen2.default.File({\n\t\t\t\tticks: this.header.PPQ\n\t\t\t});\n\n\t\t\tthis.tracks.forEach(function (track, i) {\n\t\t\t\tvar trackEncoder = output.addTrack();\n\t\t\t\ttrackEncoder.setTempo(_this3.bpm);\n\t\t\t\ttrack.encode(trackEncoder, _this3.header);\n\t\t\t});\n\t\t\treturn output.toBytes();\n\t\t}\n\n\t\t/**\n   * Conver the output encoding into a Uint8Array\n   * @return {Uint9Array} [description]\n   */\n\n\t}, {\n\t\tkey: 'toUint8Array',\n\t\tvalue: function toUint8Array() {\n\t\t\tvar encodedStr = this.encode();\n\t\t\tvar buffer = new Uint8Array(encodedStr.length);\n\t\t\tfor (var i = 0; i < encodedStr.length; i++) {\n\t\t\t\tbuffer[i] = encodedStr.charCodeAt(i);\n\t\t\t}\n\t\t\treturn buffer;\n\t\t}\n\n\t\t/**\n   * Add a new track.\n   * @param {String=} name Optionally include the name of the track\n   * @returns {Track}\n   */\n\n\t}, {\n\t\tkey: 'track',\n\t\tvalue: function track(name) {\n\t\t\tvar track = new _Track.Track(name);\n\t\t\tthis.tracks.push(track);\n\t\t\treturn track;\n\t\t}\n\n\t\t/**\n   * Get a track either by it's name or track index\n   * @param  {Number|String} trackName\n   * @return {Track}\n   */\n\n\t}, {\n\t\tkey: 'get',\n\t\tvalue: function get(trackName) {\n\t\t\tif (_Util2.default.isNumber(trackName)) {\n\t\t\t\treturn this.tracks[trackName];\n\t\t\t} else {\n\t\t\t\treturn this.tracks.find(function (t) {\n\t\t\t\t\treturn t.name === trackName;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Slice the midi file between the startTime and endTime. Returns a copy of the\n   * midi\n   * @param {Number} startTime\n   * @param {Number} endTime\n   * @returns {Midi} this\n   */\n\n\t}, {\n\t\tkey: 'slice',\n\t\tvalue: function slice() {\n\t\t\tvar startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t\t\tvar endTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.duration;\n\n\t\t\tvar midi = new Midi();\n\t\t\tmidi.header = this.header;\n\t\t\tmidi.tracks = this.tracks.map(function (t) {\n\t\t\t\treturn t.slice(startTime, endTime);\n\t\t\t});\n\t\t\treturn midi;\n\t\t}\n\n\t\t/**\n   * the time of the first event\n   * @type {Number}\n   */\n\n\t}, {\n\t\tkey: 'startTime',\n\t\tget: function get() {\n\t\t\tvar startTimes = this.tracks.map(function (t) {\n\t\t\t\treturn t.startTime;\n\t\t\t});\n\t\t\treturn Math.min.apply(Math, startTimes);\n\t\t}\n\n\t\t/**\n   * The bpm of the midi file in beats per minute\n   * @type {Number}\n   */\n\n\t}, {\n\t\tkey: 'bpm',\n\t\tget: function get() {\n\t\t\treturn this.header.bpm;\n\t\t},\n\t\tset: function set(bpm) {\n\t\t\tvar prevTempo = this.header.bpm;\n\t\t\tthis.header.bpm = bpm;\n\t\t\t//adjust the timing of all the notes\n\t\t\tvar ratio = prevTempo / bpm;\n\t\t\tthis.tracks.forEach(function (track) {\n\t\t\t\treturn track.scale(ratio);\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * The timeSignature of the midi file\n   * @type {Array}\n   */\n\n\t}, {\n\t\tkey: 'timeSignature',\n\t\tget: function get() {\n\t\t\treturn this.header.timeSignature;\n\t\t},\n\t\tset: function set(timeSig) {\n\t\t\tthis.header.timeSignature = timeSignature;\n\t\t}\n\n\t\t/** \n   * The duration is the end time of the longest track\n   * @type {Number}\n   */\n\n\t}, {\n\t\tkey: 'duration',\n\t\tget: function get() {\n\t\t\tvar durations = this.tracks.map(function (t) {\n\t\t\t\treturn t.duration;\n\t\t\t});\n\t\t\treturn Math.max.apply(Math, durations);\n\t\t}\n\t}]);\n\n\treturn Midi;\n}();\n\nexports.Midi = Midi;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvTWlkaS5qcz80ZmNhIl0sIm5hbWVzIjpbIk1pZGkiLCJoZWFkZXIiLCJicG0iLCJ0aW1lU2lnbmF0dXJlIiwiUFBRIiwidHJhY2tzIiwidXJsIiwiZGF0YSIsIm1ldGhvZCIsIlByb21pc2UiLCJzdWNjZXNzIiwiZmFpbCIsInJlcXVlc3QiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJyZXNwb25zZVR5cGUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVhZHlTdGF0ZSIsInN0YXR1cyIsImRlY29kZSIsInJlc3BvbnNlIiwic2VuZCIsImJ5dGVzIiwiQXJyYXlCdWZmZXIiLCJieXRlQXJyYXkiLCJVaW50OEFycmF5IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYXBwbHkiLCJtaWRpRGF0YSIsImZvckVhY2giLCJ0cmFja0RhdGEiLCJ0cmFjayIsInB1c2giLCJhYnNvbHV0ZVRpbWUiLCJldmVudCIsInRpY2tzVG9TZWNvbmRzIiwiZGVsdGFUaW1lIiwidHlwZSIsInN1YnR5cGUiLCJuYW1lIiwiY2xlYW5OYW1lIiwidGV4dCIsIm5vdGVPbiIsIm5vdGVOdW1iZXIiLCJ2ZWxvY2l0eSIsIm5vdGVPZmYiLCJjb250cm9sbGVyVHlwZSIsImNjIiwidmFsdWUiLCJpbnN0cnVtZW50Iiwib3V0cHV0IiwiRmlsZSIsInRpY2tzIiwiaSIsInRyYWNrRW5jb2RlciIsImFkZFRyYWNrIiwic2V0VGVtcG8iLCJlbmNvZGUiLCJ0b0J5dGVzIiwiZW5jb2RlZFN0ciIsImJ1ZmZlciIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJ0cmFja05hbWUiLCJpc051bWJlciIsImZpbmQiLCJ0Iiwic3RhcnRUaW1lIiwiZW5kVGltZSIsImR1cmF0aW9uIiwibWlkaSIsIm1hcCIsInNsaWNlIiwic3RhcnRUaW1lcyIsIk1hdGgiLCJtaW4iLCJwcmV2VGVtcG8iLCJyYXRpbyIsInNjYWxlIiwidGltZVNpZyIsImR1cmF0aW9ucyIsIm1heCJdLCJtYXBwaW5n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RSxRQUFRRCxZQUFZM0UsR0FBMUI7QUFDQSxRQUFLRyxNQUFMLENBQVl5QixPQUFaLENBQW9CLFVBQUNFLEtBQUQ7QUFBQSxXQUFXQSxNQUFNK0MsS0FBTixDQUFZRCxLQUFaLENBQVg7QUFBQSxJQUFwQjtBQUVBOztBQUVEOzs7Ozs7O3NCQUltQjtBQUNsQixVQUFPLEtBQUs3RSxNQUFMLENBQVlFLGFBQW5CO0FBQ0EsRztvQkFDaUI2RSxPLEVBQVE7QUFDekIsUUFBSy9FLE1BQUwsQ0FBWUUsYUFBWixHQUE0QkEsYUFBNUI7QUFDQTs7QUFFRDs7Ozs7OztzQkFJYztBQUNiLE9BQU04RSxZQUFZLEtBQUs1RSxNQUFMLENBQVltRSxHQUFaLENBQWdCLFVBQUNMLENBQUQ7QUFBQSxXQUFPQSxFQUFFRyxRQUFUO0FBQUEsSUFBaEIsQ0FBbEI7QUFDQSxVQUFPSyxLQUFLTyxHQUFMLENBQVN0RCxLQUFULENBQWUrQyxJQUFmLEVBQXFCTSxTQUFyQixDQUFQO0FBQ0E7Ozs7OztRQUdNakYsSSxHQUFBQSxJIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRGVjb2RlciBmcm9tICdtaWRpLWZpbGUtcGFyc2VyJ1xuaW1wb3J0IEVuY29kZXIgZnJvbSAnanNtaWRnZW4nXG5pbXBvcnQgVXRpbCBmcm9tICcuL1V0aWwnXG5pbXBvcnQge1RyYWNrfSBmcm9tICcuL1RyYWNrJ1xuaW1wb3J0IHtwYXJzZUhlYWRlcn0gZnJvbSAnLi9IZWFkZXInXG5cbi8qKlxuICogQGNsYXNzIFRoZSBNaWRpIG9iamVjdC4gQ29udGFpbnMgdHJhY2tzIGFuZCB0aGUgaGVhZGVyIGluZm8uXG4gKi9cbmNsYXNzIE1pZGkge1xuXHRjb25zdHJ1Y3Rvcigpe1xuXG5cdFx0dGhpcy5oZWFkZXIgPSB7XG5cdFx0XHQvL2RlZmF1bHRzXG5cdFx0XHRicG0gOiAxMjAsXG5cdFx0XHR0aW1lU2lnbmF0dXJlIDogWzQsIDRdLFxuXHRcdFx0UFBRIDogNDgwXG5cdFx0fVxuXG5cdFx0dGhpcy50cmFja3MgPSBbXVxuXHR9XG5cblx0LyoqXG5cdCAqIExvYWQgdGhlIGdpdmVuIHVybCBhbmQgcGFyc2UgdGhlIG1pZGkgYXQgdGhhdCB1cmxcblx0ICogQHBhcmFtICB7U3RyaW5nfSAgIHVybCAgXG5cdCAqIEBwYXJhbSB7Kn0gZGF0YSBBbnl0aGluZyB0aGF0IHNob3VsZCBiZSBzZW50IGluIHRoZSBYSFJcblx0ICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBFaXRoZXIgR0VUIG9yIFBPU1QgICAgXG5cdCAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgXG5cdCAqL1xuXHRsb2FkKHVybCwgZGF0YT1udWxsLCBtZXRob2Q9J0dFVCcpe1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgoc3VjY2VzcywgZmFpbCkgPT4ge1xuXHRcdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXHRcdFx0cmVxdWVzdC5vcGVuKG1ldGhvZCwgdXJsKVxuXHRcdFx0cmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInXG5cdFx0XHQvLyBkZWNvZGUgYXN5bmNocm9ub3VzbHlcblx0XHRcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcblx0XHRcdFx0aWYgKHJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gNCAmJiByZXF1ZXN0LnN0YXR1cyA9PT0gMjAwKXtcblx0XHRcdFx0XHRzdWNjZXNzKHRoaXMuZGVjb2RlKHJlcXVlc3QucmVzcG9uc2UpKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZhaWwocmVxdWVzdC5zdGF0dXMpXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZmFpbClcblx0XHRcdHJlcXVlc3Quc2VuZChkYXRhKVxuXHRcdH0pXG5cdH1cblxuXHQvKipcblx0ICogRGVjb2RlIHRoZSBieXRlc1xuXHQgKiBAcGFyYW0gIHtTdHJpbmd8QXJyYXlCdWZmZXJ9IGJ5dGVzIFRoZSBtaWRpIGZpbGUgZW5jb2RlZCBhcyBhIHN0cmluZyBvciBBcnJheUJ1ZmZlclxuXHQgKiBAcmV0dXJuIHtNaWRpfSAgICAgICB0aGlzXG5cdCAqL1xuXHRkZWNvZGUoYnl0ZXMpe1xuXG5cdFx0aWYgKGJ5dGVzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe1xuXHRcdFx0dmFyIGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKVxuXHRcdFx0Ynl0ZXMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVBcnJheSlcblx0XHR9XG5cblx0XHRjb25zdCBtaWRpRGF0YSA9IERlY29kZXIoYnl0ZXMpXG5cdFx0XG5cdFx0dGhpcy5oZWFkZXIgPSBwYXJzZUhlYWRlcihtaWRpRGF0YSlcblxuXHRcdC8vcmVwbGFjZSB0aGUgcHJldmlvdXMgdHJhY2tzXG5cdFx0dGhpcy50cmFja3MgPSBbXVxuXG5cdFx0bWlkaURhdGEudHJhY2tzLmZvckVhY2goKHRyYWNrRGF0YSkgPT4ge1xuXG5cdFx0XHRjb25zdCB0cmFjayA9IG5ldyBUcmFjaygpXG5cdFx0XHR0aGlzLnRyYWNrcy5wdXNoKHRyYWNrKVxuXG5cdFx0XHRsZXQgYWJzb2x1dGVUaW1lID0gMFxuXHRcdFx0dHJhY2tEYXRhLmZvckVhY2goKGV2ZW50KSA9PiB7XG5cdFx0XHRcdGFic29sdXRlVGltZSArPSBVdGlsLnRpY2tzVG9TZWNvbmRzKGV2ZW50LmRlbHRhVGltZSwgdGhpcy5oZWFkZXIpXG5cdFx0XHRcdGlmIChldmVudC50eXBlID09PSAnbWV0YScgJiYgZXZlbnQuc3VidHlwZSA9PT0gJ3RyYWNrTmFtZScpe1xuXHRcdFx0XHRcdHRyYWNrLm5hbWUgPSBVdGlsLmNsZWFuTmFtZShldmVudC50ZXh0KVxuXHRcdFx0XHR9IGVsc2UgaWYgKGV2ZW50LnN1YnR5cGUgPT09ICdub3RlT24nKXtcblx0XHRcdFx0XHR0cmFjay5ub3RlT24oZXZlbnQubm90ZU51bWJlciwgYWJzb2x1dGVUaW1lLCBldmVudC52ZWxvY2l0eSAvIDEyNylcblx0XHRcdFx0fSBlbHNlIGlmIChldmVudC5zdWJ0eXBlID09PSAnbm90ZU9mZicpe1xuXHRcdFx0XHRcdHRyYWNrLm5vdGVPZmYoZXZlbnQubm90ZU51bWJlciwgYWJzb2x1dGVUaW1lKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGV2ZW50LnN1YnR5cGUgPT09ICdjb250cm9sbGVyJyAmJiBldmVudC5jb250cm9sbGVyVHlwZSl7XG5cdFx0XHRcdFx0dHJhY2suY2MoZXZlbnQuY29udHJvbGxlclR5cGUsIGFic29sdXRlVGltZSwgZXZlbnQudmFsdWUgLyAxMjcpXG5cdFx0XHRcdH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ21ldGEnICYmIGV2ZW50LnN1YnR5cGUgPT09ICdpbnN0cnVtZW50TmFtZScpe1xuXHRcdFx0XHRcdHRyYWNrLmluc3RydW1lbnQgPSBldmVudC50ZXh0XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0fSlcblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuY29kZSB0aGUgTWlkaSBvYmplY3QgYXMgYSBCdWZmZXIgU3RyaW5nXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9XG5cdCAqL1xuXHRlbmNvZGUoKXtcblx0XHRjb25zdCBvdXRwdXQgPSBuZXcgRW5jb2Rlci5GaWxlKHtcblx0XHRcdHRpY2tzIDogdGhpcy5oZWFkZXIuUFBRXG5cdFx0fSlcblxuXHRcdHRoaXMudHJhY2tzLmZvckVhY2goKHRyYWNrLCBpKSA9PiB7XG5cdFx0XHRjb25zdCB0cmFja0VuY29kZXIgPSBvdXRwdXQuYWRkVHJhY2soKVxuXHRcdFx0dHJhY2tFbmNvZGVyLnNldFRlbXBvKHRoaXMuYnBtKVxuXHRcdFx0dHJhY2suZW5jb2RlKHRyYWNrRW5jb2RlciwgdGhpcy5oZWFkZXIpXG5cdFx0fSlcblx0XHRyZXR1cm4gb3V0cHV0LnRvQnl0ZXMoKVxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlciB0aGUgb3V0cHV0IGVuY29kaW5nIGludG8gYSBVaW50OEFycmF5XG5cdCAqIEByZXR1cm4ge1VpbnQ5QXJyYXl9IFtkZXNjcmlwdGlvbl1cblx0ICovXG5cdHRvVWludDhBcnJheSgpe1xuXHRcdGNvbnN0IGVuY29kZWRTdHIgPSB0aGlzLmVuY29kZSgpXG5cdFx0Y29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZFN0ci5sZW5ndGgpXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVkU3RyLmxlbmd0aDsgaSsrKXtcblx0XHRcdGJ1ZmZlcltpXSA9IGVuY29kZWRTdHIuY2hhckNvZGVBdChpKVxuXHRcdH1cblx0XHRyZXR1cm4gYnVmZmVyXG5cdH1cblxuXHQvKipcblx0ICogQWRkIGEgbmV3IHRyYWNrLlxuXHQgKiBAcGFyYW0ge1N0cmluZz19IG5hbWUgT3B0aW9uYWxseSBpbmNsdWRlIHRoZSBuYW1lIG9mIHRoZSB0cmFja1xuXHQgKiBAcmV0dXJucyB7VHJhY2t9XG5cdCAqL1xuXHR0cmFjayhuYW1lKXtcblx0XHRjb25zdCB0cmFjayA9IG5ldyBUcmFjayhuYW1lKVxuXHRcdHRoaXMudHJhY2tzLnB1c2godHJhY2spXG5cdFx0cmV0dXJuIHRyYWNrXG5cdH1cblxuXHQvKipcblx0ICogR2V0IGEgdHJhY2sgZWl0aGVyIGJ5IGl0J3MgbmFtZSBvciB0cmFjayBpbmRleFxuXHQgKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSB0cmFja05hbWVcblx0ICogQHJldHVybiB7VHJhY2t9XG5cdCAqL1xuXHRnZXQodHJhY2tOYW1lKXtcblx0XHRpZiAoVXRpbC5pc051bWJlcih0cmFja05hbWUpKXtcblx0XHRcdHJldHVybiB0aGlzLnRyYWNrc1t0cmFja05hbWVdXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLnRyYWNrcy5maW5kKCh0KSA9PiB0Lm5hbWUgPT09IHRyYWNrTmFtZSlcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU2xpY2UgdGhlIG1pZGkgZmlsZSBiZXR3ZWVuIHRoZSBzdGFydFRpbWUgYW5kIGVuZFRpbWUuIFJldHVybnMgYSBjb3B5IG9mIHRoZVxuXHQgKiBtaWRpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFRpbWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZFRpbWVcblx0ICogQHJldHVybnMge01pZGl9IHRoaXNcblx0ICovXG5cdHNsaWNlKHN0YXJ0VGltZT0wLCBlbmRUaW1lPXRoaXMuZHVyYXRpb24pe1xuXHRcdGNvbnN0IG1pZGkgPSBuZXcgTWlkaSgpXG5cdFx0bWlkaS5oZWFkZXIgPSB0aGlzLmhlYWRlclxuXHRcdG1pZGkudHJhY2tzID0gdGhpcy50cmFja3MubWFwKCh0KSA9PiB0LnNsaWNlKHN0YXJ0VGltZSwgZW5kVGltZSkpXG5cdFx0cmV0dXJuIG1pZGlcblx0fVxuXG5cdC8qKlxuXHQgKiB0aGUgdGltZSBvZiB0aGUgZmlyc3QgZXZlbnRcblx0ICogQHR5cGUge051bWJlcn1cblx0ICovXG5cdGdldCBzdGFydFRpbWUoKXtcblx0XHRjb25zdCBzdGFydFRpbWVzID0gdGhpcy50cmFja3MubWFwKCh0KSA9PiB0LnN0YXJ0VGltZSlcblx0XHRyZXR1cm4gTWF0aC5taW4uYXBwbHkoTWF0aCwgc3RhcnRUaW1lcylcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYnBtIG9mIHRoZSBtaWRpIGZpbGUgaW4gYmVhdHMgcGVyIG1pbnV0ZVxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKi9cblx0Z2V0IGJwbSgpe1xuXHRcdHJldHVybiB0aGlzLmhlYWRlci5icG1cblx0fVxuXHRzZXQgYnBtKGJwbSl7XG5cdFx0Y29uc3QgcHJldlRlbXBvID0gdGhpcy5oZWFkZXIuYnBtXG5cdFx0dGhpcy5oZWFkZXIuYnBtID0gYnBtXG5cdFx0Ly9hZGp1c3QgdGhlIHRpbWluZyBvZiBhbGwgdGhlIG5vdGVzXG5cdFx0Y29uc3QgcmF0aW8gPSBwcmV2VGVtcG8gLyBicG1cblx0XHR0aGlzLnRyYWNrcy5mb3JFYWNoKCh0cmFjaykgPT4gdHJhY2suc2NhbGUocmF0aW8pKVxuXG5cdH1cblxuXHQvKipcblx0ICogVGhlIHRpbWVTaWduYXR1cmUgb2YgdGhlIG1pZGkgZmlsZVxuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqL1xuXHRnZXQgdGltZVNpZ25hdHVyZSgpe1xuXHRcdHJldHVybiB0aGlzLmhlYWRlci50aW1lU2lnbmF0dXJlXG5cdH1cblx0c2V0IHRpbWVTaWduYXR1cmUodGltZVNpZyl7XG5cdFx0dGhpcy5oZWFkZXIudGltZVNpZ25hdHVyZSA9IHRpbWVTaWduYXR1cmVcblx0fVxuXG5cdC8qKiBcblx0ICogVGhlIGR1cmF0aW9uIGlzIHRoZSBlbmQgdGltZSBvZiB0aGUgbG9uZ2VzdCB0cmFja1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKi9cblx0Z2V0IGR1cmF0aW9uKCl7XG5cdFx0Y29uc3QgZHVyYXRpb25zID0gdGhpcy50cmFja3MubWFwKCh0KSA9PiB0LmR1cmF0aW9uKVxuXHRcdHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBkdXJhdGlvbnMpXG5cdH1cbn1cblxuZXhwb3J0IHtNaWRpfVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9NaWRpLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("// https://github.com/gasman/jasmid\n//\n//\n\nmodule.exports = function(file){\n\treturn MidiFile(file)\n};\n\nfunction MidiFile(data) {\n\tfunction readChunk(stream) {\n\t\tvar id = stream.read(4);\n\t\tvar length = stream.readInt32();\n\t\treturn {\n\t\t\t'id': id,\n\t\t\t'length': length,\n\t\t\t'data': stream.read(length)\n\t\t};\n\t}\n\t\n\tvar lastEventTypeByte;\n\t\n\tfunction readEvent(stream) {\n\t\tvar event = {};\n\t\tevent.deltaTime = stream.readVarInt();\n\t\tvar eventTypeByte = stream.readInt8();\n\t\tif ((eventTypeByte & 0xf0) == 0xf0) {\n\t\t\t/* system / meta event */\n\t\t\tif (eventTypeByte == 0xff) {\n\t\t\t\t/* meta event */\n\t\t\t\tevent.type = 'meta';\n\t\t\t\tvar subtypeByte = stream.readInt8();\n\t\t\t\tvar length = stream.readVarInt();\n\t\t\t\tswitch(subtypeByte) {\n\t\t\t\t\tcase 0x00:\n\t\t\t\t\t\tevent.subtype = 'sequenceNumber';\n\t\t\t\t\t\tif (length != 2) throw \"Expected length for sequenceNumber event is 2, got \" + length;\n\t\t\t\t\t\tevent.number = stream.readInt16();\n\t\t\t\t\t\treturn event;\n\t\t\t\t\tcase 0x01:\n\t\t\t\t\t\tevent.subtype = 'text';\n\t\t\t\t\t\tevent.text = stream.read(length);\n\t\t\t\t\t\treturn event;\n\t\t\t\t\tcase 0x02:\n\t\t\t\t\t\tevent.subtype = 'copyrightNotice';\n\t\t\t\t\t\tevent.text = stream.read(length);\n\t\t\t\t\t\treturn event;\n\t\t\t\t\tcase 0x03:\n\t\t\t\t\t\tevent.subtype = 'trackName';\n\t\t\t\t\t\tevent.text = stream.read(length);\n\t\t\t\t\t\treturn event;\n\t\t\t\t\tcase 0x04:\n\t\t\t\t\t\tevent.subtype = 'instrumentName';\n\t\t\t\t\t\tevent.text = stream.read(length);\n\t\t\t\t\t\treturn event;\n\t\t\t\t\tcase 0x05:\n\t\t\t\t\t\tevent.subtype = 'lyrics';\n\t\t\t\t\t\tevent.text = stream.read(length);\n\t\t\t\t\t\treturn event;\n\t\t\t\t\tcase 0x06:\n\t\t\t\t\t\tevent.subtype = 'marker';\n\t\t\t\t\t\tevent.text = stream.read(length);\n\t\t\t\t\t\treturn event;\n\t\t\t\t\tcase 0x07:\n\t\t\t\t\t\tevent.subtype = 'cuePoint';\n\t\t\t\t\t\tevent.text = stream.read(length);\n\t\t\t\t\t\treturn event;\n\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\tevent.subtype = 'midiChannelPrefix';\n\t\t\t\t\t\tif (length != 1) throw \"Expected length for midiChannelPrefix event is 1, got \" + length;\n\t\t\t\t\t\tevent.channel = stream.readInt8();\n\t\t\t\t\t\treturn event;\n\t\t\t\t\tcase 0x2f:\n\t\t\t\t\t\tevent.subtype = 'endOfTrack';\n\t\t\t\t\t\tif (length != 0) throw \"Expected length for endOfTrack event is 0, got \" + length;\n\t\t\t\t\t\treturn event;\n\t\t\t\t\tcase 0x51:\n\t\t\t\t\t\tevent.subtype = 'setTempo';\n\t\t\t\t\t\tif (length != 3) throw \"Expected length for setTempo event is 3, got \" + length;\n\t\t\t\t\t\tevent.microsecondsPerBeat = (\n\t\t\t\t\t\t\t(stream.readInt8() << 16)\n\t\t\t\t\t\t\t+ (stream.readInt8() << 8)\n\t\t\t\t\t\t\t+ stream.readInt8()\n\t\t\t\t\t\t)\n\t\t\t\t\t\treturn event;\n\t\t\t\t\tcase 0x54:\n\t\t\t\t\t\tevent.subtype = 'smpteOffset';\n\t\t\t\t\t\tif (length != 5) throw \"Expected length for smpteOffset event is 5, got \" + length;\n\t\t\t\t\t\tvar hourByte = stream.readInt8();\n\t\t\t\t\t\tevent.frameRate = {\n\t\t\t\t\t\t\t0x00: 24, 0x20: 25, 0x40: 29, 0x60: 30\n\t\t\t\t\t\t}[hourByte & 0x60];\n\t\t\t\t\t\tevent.hour = hourByte & 0x1f;\n\t\t\t\t\t\tevent.min = stream.readInt8();\n\t\t\t\t\t\tevent.sec = stream.readInt8();\n\t\t\t\t\t\tevent.frame = stream.readInt8();\n\t\t\t\t\t\tevent.subframe = stream.readInt8();\n\t\t\t\t\t\treturn event;\n\t\t\t\t\tcase 0x58:\n\t\t\t\t\t\tevent.subtype = 'timeSignature';\n\t\t\t\t\t\tif (length != 4) throw \"Expected length for timeSignature event is 4, got \" + length;\n\t\t\t\t\t\tevent.numerator = stream.readInt8();\n\t\t\t\t\t\tevent.denominator = Math.pow(2, stream.readInt8());\n\t\t\t\t\t\tevent.metronome = stream.readInt8();\n\t\t\t\t\t\tevent.thirtyseconds = stream.readInt8();\n\t\t\t\t\t\treturn event;\n\t\t\t\t\tcase 0x59:\n\t\t\t\t\t\tevent.subtype = 'keySignature';\n\t\t\t\t\t\tif (length != 2) throw \"Expected length for keySignature event is 2, got \" + length;\n\t\t\t\t\t\tevent.key = stream.readInt8(true);\n\t\t\t\t\t\tevent.scale = stream.readInt8();\n\t\t\t\t\t\treturn event;\n\t\t\t\t\tcase 0x7f:\n\t\t\t\t\t\tevent.subtype = 'sequencerSpecific';\n\t\t\t\t\t\tevent.data = stream.read(length);\n\t\t\t\t\t\treturn event;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// console.log(\"Unrecognised meta event subtype: \" + subtypeByte);\n\t\t\t\t\t\tevent.subtype = 'unknown'\n\t\t\t\t\t\tevent.data = stream.read(length);\n\t\t\t\t\t\treturn event;\n\t\t\t\t}\n\t\t\t\tevent.data = stream.read(length);\n\t\t\t\treturn event;\n\t\t\t} else if (eventTypeByte == 0xf0) {\n\t\t\t\tevent.type = 'sysEx';\n\t\t\t\tvar length = stream.readVarInt();\n\t\t\t\tevent.data = stream.read(length);\n\t\t\t\treturn event;\n\t\t\t} else if (eventTypeByte == 0xf7) {\n\t\t\t\tevent.type = 'dividedSysEx';\n\t\t\t\tvar length = stream.readVarInt();\n\t\t\t\tevent.data = stream.read(length);\n\t\t\t\treturn event;\n\t\t\t} else {\n\t\t\t\tthrow \"Unrecognised MIDI event type byte: \" + eventTypeByte;\n\t\t\t}\n\t\t} else {\n\t\t\t/* channel event */\n\t\t\tvar param1;\n\t\t\tif ((eventTypeByte & 0x80) == 0) {\n\t\t\t\t/* running status - reuse lastEventTypeByte as the event type.\n\t\t\t\t\teventTypeByte is actually the first parameter\n\t\t\t\t*/\n\t\t\t\tparam1 = eventTypeByte;\n\t\t\t\teventTypeByte = lastEventTypeByte;\n\t\t\t} else {\n\t\t\t\tparam1 = stream.readInt8();\n\t\t\t\tlastEventTypeByte = eventTypeByte;\n\t\t\t}\n\t\t\tvar eventType = eventTypeByte >> 4;\n\t\t\tevent.channel = eventTypeByte & 0x0f;\n\t\t\tevent.type = 'channel';\n\t\t\tswitch (eventType) {\n\t\t\t\tcase 0x08:\n\t\t\t\t\tevent.subtype = 'noteOff';\n\t\t\t\t\tevent.noteNumber = param1;\n\t\t\t\t\tevent.velocity = stream.readInt8();\n\t\t\t\t\treturn event;\n\t\t\t\tcase 0x09:\n\t\t\t\t\tevent.noteNumber = param1;\n\t\t\t\t\tevent.velocity = stream.readInt8();\n\t\t\t\t\tif (event.velocity == 0) {\n\t\t\t\t\t\tevent.subtype = 'noteOff';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tevent.subtype = 'noteOn';\n\t\t\t\t\t}\n\t\t\t\t\treturn event;\n\t\t\t\tcase 0x0a:\n\t\t\t\t\tevent.subtype = 'noteAftertouch';\n\t\t\t\t\tevent.noteNumber = param1;\n\t\t\t\t\tevent.amount = stream.readInt8();\n\t\t\t\t\treturn event;\n\t\t\t\tcase 0x0b:\n\t\t\t\t\tevent.subtype = 'controller';\n\t\t\t\t\tevent.controllerType = param1;\n\t\t\t\t\tevent.value = stream.readInt8();\n\t\t\t\t\treturn event;\n\t\t\t\tcase 0x0c:\n\t\t\t\t\tevent.subtype = 'programChange';\n\t\t\t\t\tevent.programNumber = param1;\n\t\t\t\t\treturn event;\n\t\t\t\tcase 0x0d:\n\t\t\t\t\tevent.subtype = 'channelAftertouch';\n\t\t\t\t\tevent.amount = param1;\n\t\t\t\t\treturn event;\n\t\t\t\tcase 0x0e:\n\t\t\t\t\tevent.subtype = 'pitchBend';\n\t\t\t\t\tevent.value = param1 + (stream.readInt8() << 7);\n\t\t\t\t\treturn event;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow \"Unrecognised MIDI event type: \" + eventType\n\t\t\t\t\t/* \n\t\t\t\t\tconsole.log(\"Unrecognised MIDI event type: \" + eventType);\n\t\t\t\t\tstream.readInt8();\n\t\t\t\t\tevent.subtype = 'unknown';\n\t\t\t\t\treturn event;\n\t\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstream = Stream(data);\n\tvar headerChunk = readChunk(stream);\n\tif (headerChunk.id != 'MThd' || headerChunk.length != 6) {\n\t\tthrow \"Bad .mid file - header not found\";\n\t}\n\tvar headerStream = Stream(headerChunk.data);\n\tvar formatType = headerStream.readInt16();\n\tvar trackCount = headerStream.readInt16();\n\tvar timeDivision = headerStream.readInt16();\n\t\n\tif (timeDivision & 0x8000) {\n\t\tthrow \"Expressing time division in SMTPE frames is not supported yet\"\n\t} else {\n\t\tticksPerBeat = timeDivision;\n\t}\n\t\n\tvar header = {\n\t\t'formatType': formatType,\n\t\t'trackCount': trackCount,\n\t\t'ticksPerBeat': ticksPerBeat\n\t}\n\tvar tracks = [];\n\tfor (var i = 0; i < header.trackCount; i++) {\n\t\ttracks[i] = [];\n\t\tvar trackChunk = readChunk(stream);\n\t\tif (trackChunk.id != 'MTrk') {\n\t\t\tthrow \"Unexpected chunk - expected MTrk, got \"+ trackChunk.id;\n\t\t}\n\t\tvar trackStream = Stream(trackChunk.data);\n\t\twhile (!trackStream.eof()) {\n\t\t\tvar event = readEvent(trackStream);\n\t\t\ttracks[i].push(event);\n\t\t\t//console.log(event);\n\t\t}\n\t}\n\t\n\treturn {\n\t\t'header': header,\n\t\t'tracks': tracks\n\t}\n};\n\n/* Wrapper for accessing strings through sequential reads */\nfunction Stream(str) {\n\tvar position = 0;\n\t\n\tfunction read(length) {\n\t\tvar result = str.substr(position, length);\n\t\tposition += length;\n\t\treturn result;\n\t}\n\t\n\t/* read a big-endian 32-bit integer */\n\tfunction readInt32() {\n\t\tvar result = (\n\t\t\t(str.charCodeAt(position) << 24)\n\t\t\t+ (str.charCodeAt(position + 1) << 16)\n\t\t\t+ (str.charCodeAt(position + 2) << 8)\n\t\t\t+ str.charCodeAt(position + 3));\n\t\tposition += 4;\n\t\treturn result;\n\t}\n\n\t/* read a big-endian 16-bit integer */\n\tfunction readInt16() {\n\t\tvar result = (\n\t\t\t(str.charCodeAt(position) << 8)\n\t\t\t+ str.charCodeAt(position + 1));\n\t\tposition += 2;\n\t\treturn result;\n\t}\n\t\n\t/* read an 8-bit integer */\n\tfunction readInt8(signed) {\n\t\tvar result = str.charCodeAt(position);\n\t\tif (signed && result > 127) result -= 256;\n\t\tposition += 1;\n\t\treturn result;\n\t}\n\t\n\tfunction eof() {\n\t\treturn position >= str.length;\n\t}\n\t\n\t/* read a MIDI-style variable-length integer\n\t\t(big-endian value in groups of 7 bits,\n\t\twith top bit set to signify that another byte follows)\n\t*/\n\tfunction readVarInt() {\n\t\tvar result = 0;\n\t\twhile (true) {\n\t\t\tvar b = readInt8();\n\t\t\tif (b & 0x80) {\n\t\t\t\tresult += (b & 0x7f);\n\t\t\t\tresult <<= 7;\n\t\t\t} else {\n\t\t\t\t/* b is the last byte */\n\t\t\t\treturn result + b;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn {\n\t\t'eof': eof,\n\t\t'read': read,\n\t\t'readInt32': readInt32,\n\t\t'readInt16': readInt16,\n\t\t'readInt8': readInt8,\n\t\t'readVarInt': readVarInt\n\t}\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21pZGktZmlsZS1wYXJzZXIvaW5kZXguanM/ODZlNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXRodWIuY29tL2dhc21hbi9qYXNtaWRcbi8vXG4vL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZpbGUpe1xuXHRyZXR1cm4gTWlkaUZpbGUoZmlsZSlcbn07XG5cbmZ1bmN0aW9uIE1pZGlGaWxlKGRhdGEpIHtcblx0ZnVuY3Rpb24gcmVhZENodW5rKHN0cmVhbSkge1xuXHRcdHZhciBpZCA9IHN0cmVhbS5yZWFkKDQpO1xuXHRcdHZhciBsZW5ndGggPSBzdHJlYW0ucmVhZEludDMyKCk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdCdpZCc6IGlkLFxuXHRcdFx0J2xlbmd0aCc6IGxlbmd0aCxcblx0XHRcdCdkYXRhJzogc3RyZWFtLnJlYWQobGVuZ3RoKVxuXHRcdH07XG5cdH1cblx0XG5cdHZhciBsYXN0RXZlbnRUeXBlQnl0ZTtcblx0XG5cdGZ1bmN0aW9uIHJlYWRFdmVudChzdHJlYW0pIHtcblx0XHR2YXIgZXZlbnQgPSB7fTtcblx0XHRldmVudC5kZWx0YVRpbWUgPSBzdHJlYW0ucmVhZFZhckludCgpO1xuXHRcdHZhciBldmVudFR5cGVCeXRlID0gc3RyZWFtLnJlYWRJbnQ4KCk7XG5cdFx0aWYgKChldmVudFR5cGVCeXRlICYgMHhmMCkgPT0gMHhmMCkge1xuXHRcdFx0Lyogc3lzdGVtIC8gbWV0YSBldmVudCAqL1xuXHRcdFx0aWYgKGV2ZW50VHlwZUJ5dGUgPT0gMHhmZikge1xuXHRcdFx0XHQvKiBtZXRhIGV2ZW50ICovXG5cdFx0XHRcdGV2ZW50LnR5cGUgPSAnbWV0YSc7XG5cdFx0XHRcdHZhciBzdWJ0eXBlQnl0ZSA9IHN0cmVhbS5yZWFkSW50OCgpO1xuXHRcdFx0XHR2YXIgbGVuZ3RoID0gc3RyZWFtLnJlYWRWYXJJbnQoKTtcblx0XHRcdFx0c3dpdGNoKHN1YnR5cGVCeXRlKSB7XG5cdFx0XHRcdFx0Y2FzZSAweDAwOlxuXHRcdFx0XHRcdFx0ZXZlbnQuc3VidHlwZSA9ICdzZXF1ZW5jZU51bWJlcic7XG5cdFx0XHRcdFx0XHRpZiAobGVuZ3RoICE9IDIpIHRocm93IFwiRXhwZWN0ZWQgbGVuZ3RoIGZvciBzZXF1ZW5jZU51bWJlciBldmVudCBpcyAyLCBnb3QgXCIgKyBsZW5ndGg7XG5cdFx0XHRcdFx0XHRldmVudC5udW1iZXIgPSBzdHJlYW0ucmVhZEludDE2KCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0XHRcdFx0Y2FzZSAweDAxOlxuXHRcdFx0XHRcdFx0ZXZlbnQuc3VidHlwZSA9ICd0ZXh0Jztcblx0XHRcdFx0XHRcdGV2ZW50LnRleHQgPSBzdHJlYW0ucmVhZChsZW5ndGgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdFx0XHRcdGNhc2UgMHgwMjpcblx0XHRcdFx0XHRcdGV2ZW50LnN1YnR5cGUgPSAnY29weXJpZ2h0Tm90aWNlJztcblx0XHRcdFx0XHRcdGV2ZW50LnRleHQgPSBzdHJlYW0ucmVhZChsZW5ndGgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdFx0XHRcdGNhc2UgMHgwMzpcblx0XHRcdFx0XHRcdGV2ZW50LnN1YnR5cGUgPSAndHJhY2tOYW1lJztcblx0XHRcdFx0XHRcdGV2ZW50LnRleHQgPSBzdHJlYW0ucmVhZChsZW5ndGgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdFx0XHRcdGNhc2UgMHgwNDpcblx0XHRcdFx0XHRcdGV2ZW50LnN1YnR5cGUgPSAnaW5zdHJ1bWVudE5hbWUnO1xuXHRcdFx0XHRcdFx0ZXZlbnQudGV4dCA9IHN0cmVhbS5yZWFkKGxlbmd0aCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0XHRcdFx0Y2FzZSAweDA1OlxuXHRcdFx0XHRcdFx0ZXZlbnQuc3VidHlwZSA9ICdseXJpY3MnO1xuXHRcdFx0XHRcdFx0ZXZlbnQudGV4dCA9IHN0cmVhbS5yZWFkKGxlbmd0aCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0XHRcdFx0Y2FzZSAweDA2OlxuXHRcdFx0XHRcdFx0ZXZlbnQuc3VidHlwZSA9ICdtYXJrZXInO1xuXHRcdFx0XHRcdFx0ZXZlbnQudGV4dCA9IHN0cmVhbS5yZWFkKGxlbmd0aCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0XHRcdFx0Y2FzZSAweDA3OlxuXHRcdFx0XHRcdFx0ZXZlbnQuc3VidHlwZSA9ICdjdWVQb2ludCc7XG5cdFx0XHRcdFx0XHRldmVudC50ZXh0ID0gc3RyZWFtLnJlYWQobGVuZ3RoKTtcblx0XHRcdFx0XHRcdHJldHVybiBldmVudDtcblx0XHRcdFx0XHRjYXNlIDB4MjA6XG5cdFx0XHRcdFx0XHRldmVudC5zdWJ0eXBlID0gJ21pZGlDaGFubmVsUHJlZml4Jztcblx0XHRcdFx0XHRcdGlmIChsZW5ndGggIT0gMSkgdGhyb3cgXCJFeHBlY3RlZCBsZW5ndGggZm9yIG1pZGlDaGFubmVsUHJlZml4IGV2ZW50IGlzIDEsIGdvdCBcIiArIGxlbmd0aDtcblx0XHRcdFx0XHRcdGV2ZW50LmNoYW5uZWwgPSBzdHJlYW0ucmVhZEludDgoKTtcblx0XHRcdFx0XHRcdHJldHVybiBldmVudDtcblx0XHRcdFx0XHRjYXNlIDB4MmY6XG5cdFx0XHRcdFx0XHRldmVudC5zdWJ0eXBlID0gJ2VuZE9mVHJhY2snO1xuXHRcdFx0XHRcdFx0aWYgKGxlbmd0aCAhPSAwKSB0aHJvdyBcIkV4cGVjdGVkIGxlbmd0aCBmb3IgZW5kT2ZUcmFjayBldmVudCBpcyAwLCBnb3QgXCIgKyBsZW5ndGg7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0XHRcdFx0Y2FzZSAweDUxOlxuXHRcdFx0XHRcdFx0ZXZlbnQuc3VidHlwZSA9ICdzZXRUZW1wbyc7XG5cdFx0XHRcdFx0XHRpZiAobGVuZ3RoICE9IDMpIHRocm93IFwiRXhwZWN0ZWQgbGVuZ3RoIGZvciBzZXRUZW1wbyBldmVudCBpcyAzLCBnb3QgXCIgKyBsZW5ndGg7XG5cdFx0XHRcdFx0XHRldmVudC5taWNyb3NlY29uZHNQZXJCZWF0ID0gKFxuXHRcdFx0XHRcdFx0XHQoc3RyZWFtLnJlYWRJbnQ4KCkgPDwgMTYpXG5cdFx0XHRcdFx0XHRcdCsgKHN0cmVhbS5yZWFkSW50OCgpIDw8IDgpXG5cdFx0XHRcdFx0XHRcdCsgc3RyZWFtLnJlYWRJbnQ4KClcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdHJldHVybiBldmVudDtcblx0XHRcdFx0XHRjYXNlIDB4NTQ6XG5cdFx0XHRcdFx0XHRldmVudC5zdWJ0eXBlID0gJ3NtcHRlT2Zmc2V0Jztcblx0XHRcdFx0XHRcdGlmIChsZW5ndGggIT0gNSkgdGhyb3cgXCJFeHBlY3RlZCBsZW5ndGggZm9yIHNtcHRlT2Zmc2V0IGV2ZW50IGlzIDUsIGdvdCBcIiArIGxlbmd0aDtcblx0XHRcdFx0XHRcdHZhciBob3VyQnl0ZSA9IHN0cmVhbS5yZWFkSW50OCgpO1xuXHRcdFx0XHRcdFx0ZXZlbnQuZnJhbWVSYXRlID0ge1xuXHRcdFx0XHRcdFx0XHQweDAwOiAyNCwgMHgyMDogMjUsIDB4NDA6IDI5LCAweDYwOiAzMFxuXHRcdFx0XHRcdFx0fVtob3VyQnl0ZSAmIDB4NjBdO1xuXHRcdFx0XHRcdFx0ZXZlbnQuaG91ciA9IGhvdXJCeXRlICYgMHgxZjtcblx0XHRcdFx0XHRcdGV2ZW50Lm1pbiA9IHN0cmVhbS5yZWFkSW50OCgpO1xuXHRcdFx0XHRcdFx0ZXZlbnQuc2VjID0gc3RyZWFtLnJlYWRJbnQ4KCk7XG5cdFx0XHRcdFx0XHRldmVudC5mcmFtZSA9IHN0cmVhbS5yZWFkSW50OCgpO1xuXHRcdFx0XHRcdFx0ZXZlbnQuc3ViZnJhbWUgPSBzdHJlYW0ucmVhZEludDgoKTtcblx0XHRcdFx0XHRcdHJldHVybiBldmVudDtcblx0XHRcdFx0XHRjYXNlIDB4NTg6XG5cdFx0XHRcdFx0XHRldmVudC5zdWJ0eXBlID0gJ3RpbWVTaWduYXR1cmUnO1xuXHRcdFx0XHRcdFx0aWYgKGxlbmd0aCAhPSA0KSB0aHJvdyBcIkV4cGVjdGVkIGxlbmd0aCBmb3IgdGltZVNpZ25hdHVyZSBldmVudCBpcyA0LCBnb3QgXCIgKyBsZW5ndGg7XG5cdFx0XHRcdFx0XHRldmVudC5udW1lcmF0b3IgPSBzdHJlYW0ucmVhZEludDgoKTtcblx0XHRcdFx0XHRcdGV2ZW50LmRlbm9taW5hdG9yID0gTWF0aC5wb3coMiwgc3RyZWFtLnJlYWRJbnQ4KCkpO1xuXHRcdFx0XHRcdFx0ZXZlbnQubWV0cm9ub21lID0gc3RyZWFtLnJlYWRJbnQ4KCk7XG5cdFx0XHRcdFx0XHRldmVudC50aGlydHlzZWNvbmRzID0gc3RyZWFtLnJlYWRJbnQ4KCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0XHRcdFx0Y2FzZSAweDU5OlxuXHRcdFx0XHRcdFx0ZXZlbnQuc3VidHlwZSA9ICdrZXlTaWduYXR1cmUnO1xuXHRcdFx0XHRcdFx0aWYgKGxlbmd0aCAhPSAyKSB0aHJvdyBcIkV4cGVjdGVkIGxlbmd0aCBmb3Iga2V5U2lnbmF0dXJlIGV2ZW50IGlzIDIsIGdvdCBcIiArIGxlbmd0aDtcblx0XHRcdFx0XHRcdGV2ZW50LmtleSA9IHN0cmVhbS5yZWFkSW50OCh0cnVlKTtcblx0XHRcdFx0XHRcdGV2ZW50LnNjYWxlID0gc3RyZWFtLnJlYWRJbnQ4KCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0XHRcdFx0Y2FzZSAweDdmOlxuXHRcdFx0XHRcdFx0ZXZlbnQuc3VidHlwZSA9ICdzZXF1ZW5jZXJTcGVjaWZpYyc7XG5cdFx0XHRcdFx0XHRldmVudC5kYXRhID0gc3RyZWFtLnJlYWQobGVuZ3RoKTtcblx0XHRcdFx0XHRcdHJldHVybiBldmVudDtcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJVbnJlY29nbmlzZWQgbWV0YSBldmVudCBzdWJ0eXBlOiBcIiArIHN1YnR5cGVCeXRlKTtcblx0XHRcdFx0XHRcdGV2ZW50LnN1YnR5cGUgPSAndW5rbm93bidcblx0XHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBzdHJlYW0ucmVhZChsZW5ndGgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGV2ZW50LmRhdGEgPSBzdHJlYW0ucmVhZChsZW5ndGgpO1xuXHRcdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0XHR9IGVsc2UgaWYgKGV2ZW50VHlwZUJ5dGUgPT0gMHhmMCkge1xuXHRcdFx0XHRldmVudC50eXBlID0gJ3N5c0V4Jztcblx0XHRcdFx0dmFyIGxlbmd0aCA9IHN0cmVhbS5yZWFkVmFySW50KCk7XG5cdFx0XHRcdGV2ZW50LmRhdGEgPSBzdHJlYW0ucmVhZChsZW5ndGgpO1xuXHRcdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0XHR9IGVsc2UgaWYgKGV2ZW50VHlwZUJ5dGUgPT0gMHhmNykge1xuXHRcdFx0XHRldmVudC50eXBlID0gJ2RpdmlkZWRTeXNFeCc7XG5cdFx0XHRcdHZhciBsZW5ndGggPSBzdHJlYW0ucmVhZFZhckludCgpO1xuXHRcdFx0XHRldmVudC5kYXRhID0gc3RyZWFtLnJlYWQobGVuZ3RoKTtcblx0XHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgXCJVbnJlY29nbmlzZWQgTUlESSBldmVudCB0eXBlIGJ5dGU6IFwiICsgZXZlbnRUeXBlQnl0ZTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0LyogY2hhbm5lbCBldmVudCAqL1xuXHRcdFx0dmFyIHBhcmFtMTtcblx0XHRcdGlmICgoZXZlbnRUeXBlQnl0ZSAmIDB4ODApID09IDApIHtcblx0XHRcdFx0LyogcnVubmluZyBzdGF0dXMgLSByZXVzZSBsYXN0RXZlbnRUeXBlQnl0ZSBhcyB0aGUgZXZlbnQgdHlwZS5cblx0XHRcdFx0XHRldmVudFR5cGVCeXRlIGlzIGFjdHVhbGx5IHRoZSBmaXJzdCBwYXJhbWV0ZXJcblx0XHRcdFx0Ki9cblx0XHRcdFx0cGFyYW0xID0gZXZlbnRUeXBlQnl0ZTtcblx0XHRcdFx0ZXZlbnRUeXBlQnl0ZSA9IGxhc3RFdmVudFR5cGVCeXRlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGFyYW0xID0gc3RyZWFtLnJlYWRJbnQ4KCk7XG5cdFx0XHRcdGxhc3RFdmVudFR5cGVCeXRlID0gZXZlbnRUeXBlQnl0ZTtcblx0XHRcdH1cblx0XHRcdHZhciBldmVudFR5cGUgPSBldmVudFR5cGVCeXRlID4+IDQ7XG5cdFx0XHRldmVudC5jaGFubmVsID0gZXZlbnRUeXBlQnl0ZSAmIDB4MGY7XG5cdFx0XHRldmVudC50eXBlID0gJ2NoYW5uZWwnO1xuXHRcdFx0c3dpdGNoIChldmVudFR5cGUpIHtcblx0XHRcdFx0Y2FzZSAweDA4OlxuXHRcdFx0XHRcdGV2ZW50LnN1YnR5cGUgPSAnbm90ZU9mZic7XG5cdFx0XHRcdFx0ZXZlbnQubm90ZU51bWJlciA9IHBhcmFtMTtcblx0XHRcdFx0XHRldmVudC52ZWxvY2l0eSA9IHN0cmVhbS5yZWFkSW50OCgpO1xuXHRcdFx0XHRcdHJldHVybiBldmVudDtcblx0XHRcdFx0Y2FzZSAweDA5OlxuXHRcdFx0XHRcdGV2ZW50Lm5vdGVOdW1iZXIgPSBwYXJhbTE7XG5cdFx0XHRcdFx0ZXZlbnQudmVsb2NpdHkgPSBzdHJlYW0ucmVhZEludDgoKTtcblx0XHRcdFx0XHRpZiAoZXZlbnQudmVsb2NpdHkgPT0gMCkge1xuXHRcdFx0XHRcdFx0ZXZlbnQuc3VidHlwZSA9ICdub3RlT2ZmJztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZXZlbnQuc3VidHlwZSA9ICdub3RlT24nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0XHRcdGNhc2UgMHgwYTpcblx0XHRcdFx0XHRldmVudC5zdWJ0eXBlID0gJ25vdGVBZnRlcnRvdWNoJztcblx0XHRcdFx0XHRldmVudC5ub3RlTnVtYmVyID0gcGFyYW0xO1xuXHRcdFx0XHRcdGV2ZW50LmFtb3VudCA9IHN0cmVhbS5yZWFkSW50OCgpO1xuXHRcdFx0XHRcdHJldHVybiBldmVudDtcblx0XHRcdFx0Y2FzZSAweDBiOlxuXHRcdFx0XHRcdGV2ZW50LnN1YnR5cGUgPSAnY29udHJvbGxlcic7XG5cdFx0XHRcdFx0ZXZlbnQuY29udHJvbGxlclR5cGUgPSBwYXJhbTE7XG5cdFx0XHRcdFx0ZXZlbnQudmFsdWUgPSBzdHJlYW0ucmVhZEludDgoKTtcblx0XHRcdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0XHRcdGNhc2UgMHgwYzpcblx0XHRcdFx0XHRldmVudC5zdWJ0eXBlID0gJ3Byb2dyYW1DaGFuZ2UnO1xuXHRcdFx0XHRcdGV2ZW50LnByb2dyYW1OdW1iZXIgPSBwYXJhbTE7XG5cdFx0XHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdFx0XHRjYXNlIDB4MGQ6XG5cdFx0XHRcdFx0ZXZlbnQuc3VidHlwZSA9ICdjaGFubmVsQWZ0ZXJ0b3VjaCc7XG5cdFx0XHRcdFx0ZXZlbnQuYW1vdW50ID0gcGFyYW0xO1xuXHRcdFx0XHRcdHJldHVybiBldmVudDtcblx0XHRcdFx0Y2FzZSAweDBlOlxuXHRcdFx0XHRcdGV2ZW50LnN1YnR5cGUgPSAncGl0Y2hCZW5kJztcblx0XHRcdFx0XHRldmVudC52YWx1ZSA9IHBhcmFtMSArIChzdHJlYW0ucmVhZEludDgoKSA8PCA3KTtcblx0XHRcdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgXCJVbnJlY29nbmlzZWQgTUlESSBldmVudCB0eXBlOiBcIiArIGV2ZW50VHlwZVxuXHRcdFx0XHRcdC8qIFxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiVW5yZWNvZ25pc2VkIE1JREkgZXZlbnQgdHlwZTogXCIgKyBldmVudFR5cGUpO1xuXHRcdFx0XHRcdHN0cmVhbS5yZWFkSW50OCgpO1xuXHRcdFx0XHRcdGV2ZW50LnN1YnR5cGUgPSAndW5rbm93bic7XG5cdFx0XHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdFx0XHRcdCovXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRzdHJlYW0gPSBTdHJlYW0oZGF0YSk7XG5cdHZhciBoZWFkZXJDaHVuayA9IHJlYWRDaHVuayhzdHJlYW0pO1xuXHRpZiAoaGVhZGVyQ2h1bmsuaWQgIT0gJ01UaGQnIHx8IGhlYWRlckNodW5rLmxlbmd0aCAhPSA2KSB7XG5cdFx0dGhyb3cgXCJCYWQgLm1pZCBmaWxlIC0gaGVhZGVyIG5vdCBmb3VuZFwiO1xuXHR9XG5cdHZhciBoZWFkZXJTdHJlYW0gPSBTdHJlYW0oaGVhZGVyQ2h1bmsuZGF0YSk7XG5cdHZhciBmb3JtYXRUeXBlID0gaGVhZGVyU3RyZWFtLnJlYWRJbnQxNigpO1xuXHR2YXIgdHJhY2tDb3VudCA9IGhlYWRlclN0cmVhbS5yZWFkSW50MTYoKTtcblx0dmFyIHRpbWVEaXZpc2lvbiA9IGhlYWRlclN0cmVhbS5yZWFkSW50MTYoKTtcblx0XG5cdGlmICh0aW1lRGl2aXNpb24gJiAweDgwMDApIHtcblx0XHR0aHJvdyBcIkV4cHJlc3NpbmcgdGltZSBkaXZpc2lvbiBpbiBTTVRQRSBmcmFtZXMgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIlxuXHR9IGVsc2Uge1xuXHRcdHRpY2tzUGVyQmVhdCA9IHRpbWVEaXZpc2lvbjtcblx0fVxuXHRcblx0dmFyIGhlYWRlciA9IHtcblx0XHQnZm9ybWF0VHlwZSc6IGZvcm1hdFR5cGUsXG5cdFx0J3RyYWNrQ291bnQnOiB0cmFja0NvdW50LFxuXHRcdCd0aWNrc1BlckJlYXQnOiB0aWNrc1BlckJlYXRcblx0fVxuXHR2YXIgdHJhY2tzID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVyLnRyYWNrQ291bnQ7IGkrKykge1xuXHRcdHRyYWNrc1tpXSA9IFtdO1xuXHRcdHZhciB0cmFja0NodW5rID0gcmVhZENodW5rKHN0cmVhbSk7XG5cdFx0aWYgKHRyYWNrQ2h1bmsuaWQgIT0gJ01UcmsnKSB7XG5cdFx0XHR0aHJvdyBcIlVuZXhwZWN0ZWQgY2h1bmsgLSBleHBlY3RlZCBNVHJrLCBnb3QgXCIrIHRyYWNrQ2h1bmsuaWQ7XG5cdFx0fVxuXHRcdHZhciB0cmFja1N0cmVhbSA9IFN0cmVhbSh0cmFja0NodW5rLmRhdGEpO1xuXHRcdHdoaWxlICghdHJhY2tTdHJlYW0uZW9mKCkpIHtcblx0XHRcdHZhciBldmVudCA9IHJlYWRFdmVudCh0cmFja1N0cmVhbSk7XG5cdFx0XHR0cmFja3NbaV0ucHVzaChldmVudCk7XG5cdFx0XHQvL2NvbnNvbGUubG9nKGV2ZW50KTtcblx0XHR9XG5cdH1cblx0XG5cdHJldHVybiB7XG5cdFx0J2hlYWRlcic6IGhlYWRlcixcblx0XHQndHJhY2tzJzogdHJhY2tzXG5cdH1cbn07XG5cbi8qIFdyYXBwZXIgZm9yIGFjY2Vzc2luZyBzdHJpbmdzIHRocm91Z2ggc2VxdWVudGlhbCByZWFkcyAqL1xuZnVuY3Rpb24gU3RyZWFtKHN0cikge1xuXHR2YXIgcG9zaXRpb24gPSAwO1xuXHRcblx0ZnVuY3Rpb24gcmVhZChsZW5ndGgpIHtcblx0XHR2YXIgcmVzdWx0ID0gc3RyLnN1YnN0cihwb3NpdGlvbiwgbGVuZ3RoKTtcblx0XHRwb3NpdGlvbiArPSBsZW5ndGg7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXHRcblx0LyogcmVhZCBhIGJpZy1lbmRpYW4gMzItYml0IGludGVnZXIgKi9cblx0ZnVuY3Rpb24gcmVhZEludDMyKCkge1xuXHRcdHZhciByZXN1bHQgPSAoXG5cdFx0XHQoc3RyLmNoYXJDb2RlQXQocG9zaXRpb24pIDw8IDI0KVxuXHRcdFx0KyAoc3RyLmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSA8PCAxNilcblx0XHRcdCsgKHN0ci5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMikgPDwgOClcblx0XHRcdCsgc3RyLmNoYXJDb2RlQXQocG9zaXRpb24gKyAzKSk7XG5cdFx0cG9zaXRpb24gKz0gNDtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyogcmVhZCBhIGJpZy1lbmRpYW4gMTYtYml0IGludGVnZXIgKi9cblx0ZnVuY3Rpb24gcmVhZEludDE2KCkge1xuXHRcdHZhciByZXN1bHQgPSAoXG5cdFx0XHQoc3RyLmNoYXJDb2RlQXQocG9zaXRpb24pIDw8IDgpXG5cdFx0XHQrIHN0ci5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkpO1xuXHRcdHBvc2l0aW9uICs9IDI7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXHRcblx0LyogcmVhZCBhbiA4LWJpdCBpbnRlZ2VyICovXG5cdGZ1bmN0aW9uIHJlYWRJbnQ4KHNpZ25lZCkge1xuXHRcdHZhciByZXN1bHQgPSBzdHIuY2hhckNvZGVBdChwb3NpdGlvbik7XG5cdFx0aWYgKHNpZ25lZCAmJiByZXN1bHQgPiAxMjcpIHJlc3VsdCAtPSAyNTY7XG5cdFx0cG9zaXRpb24gKz0gMTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBlb2YoKSB7XG5cdFx0cmV0dXJuIHBvc2l0aW9uID49IHN0ci5sZW5ndGg7XG5cdH1cblx0XG5cdC8qIHJlYWQgYSBNSURJLXN0eWxlIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0KGJpZy1lbmRpYW4gdmFsdWUgaW4gZ3JvdXBzIG9mIDcgYml0cyxcblx0XHR3aXRoIHRvcCBiaXQgc2V0IHRvIHNpZ25pZnkgdGhhdCBhbm90aGVyIGJ5dGUgZm9sbG93cylcblx0Ki9cblx0ZnVuY3Rpb24gcmVhZFZhckludCgpIHtcblx0XHR2YXIgcmVzdWx0ID0gMDtcblx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0dmFyIGIgPSByZWFkSW50OCgpO1xuXHRcdFx0aWYgKGIgJiAweDgwKSB7XG5cdFx0XHRcdHJlc3VsdCArPSAoYiAmIDB4N2YpO1xuXHRcdFx0XHRyZXN1bHQgPDw9IDc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvKiBiIGlzIHRoZSBsYXN0IGJ5dGUgKi9cblx0XHRcdFx0cmV0dXJuIHJlc3VsdCArIGI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRyZXR1cm4ge1xuXHRcdCdlb2YnOiBlb2YsXG5cdFx0J3JlYWQnOiByZWFkLFxuXHRcdCdyZWFkSW50MzInOiByZWFkSW50MzIsXG5cdFx0J3JlYWRJbnQxNic6IHJlYWRJbnQxNixcblx0XHQncmVhZEludDgnOiByZWFkSW50OCxcblx0XHQncmVhZFZhckludCc6IHJlYWRWYXJJbnRcblx0fVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9taWRpLWZpbGUtcGFyc2VyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(module) {var Midi = {};\n\n(function(exported) {\n\n\tvar DEFAULT_VOLUME   = exported.DEFAULT_VOLUME   = 90;\n\tvar DEFAULT_DURATION = exported.DEFAULT_DURATION = 128;\n\tvar DEFAULT_CHANNEL  = exported.DEFAULT_CHANNEL  = 0;\n\n\t/* ******************************************************************\n\t * Utility functions\n\t ****************************************************************** */\n\n\tvar Util = {\n\n\t\tmidi_letter_pitches: { a:21, b:23, c:12, d:14, e:16, f:17, g:19 },\n\n\t\t/**\n\t\t * Convert a symbolic note name (e.g. \"c4\") to a numeric MIDI pitch (e.g.\n\t\t * 60, middle C).\n\t\t *\n\t\t * @param {string} n - The symbolic note name to parse.\n\t\t * @returns {number} The MIDI pitch that corresponds to the symbolic note\n\t\t * name.\n\t\t */\n\t\tmidiPitchFromNote: function(n) {\n\t\t\tvar matches = /([a-g])(#+|b+)?([0-9]+)$/i.exec(n);\n\t\t\tvar note = matches[1].toLowerCase(), accidental = matches[2] || '', octave = parseInt(matches[3], 10);\n\t\t\treturn (12 * octave) + Util.midi_letter_pitches[note] + (accidental.substr(0,1)=='#'?1:-1) * accidental.length;\n\t\t},\n\n\t\t/**\n\t\t * Ensure that the given argument is converted to a MIDI pitch. Note that\n\t\t * it may already be one (including a purely numeric string).\n\t\t *\n\t\t * @param {string|number} p - The pitch to convert.\n\t\t * @returns {number} The resulting numeric MIDI pitch.\n\t\t */\n\t\tensureMidiPitch: function(p) {\n\t\t\tif (typeof p == 'number' || !/[^0-9]/.test(p)) {\n\t\t\t\t// numeric pitch\n\t\t\t\treturn parseInt(p, 10);\n\t\t\t} else {\n\t\t\t\t// assume it's a note name\n\t\t\t\treturn Util.midiPitchFromNote(p);\n\t\t\t}\n\t\t},\n\n\t\tmidi_pitches_letter: { '12':'c', '13':'c#', '14':'d', '15':'d#', '16':'e', '17':'f', '18':'f#', '19':'g', '20':'g#', '21':'a', '22':'a#', '23':'b' },\n\t\tmidi_flattened_notes: { 'a#':'bb', 'c#':'db', 'd#':'eb', 'f#':'gb', 'g#':'ab' },\n\n\t\t/**\n\t\t * Convert a numeric MIDI pitch value (e.g. 60) to a symbolic note name\n\t\t * (e.g. \"c4\").\n\t\t *\n\t\t * @param {number} n - The numeric MIDI pitch value to convert.\n\t\t * @param {boolean} [returnFlattened=false] - Whether to prefer flattened\n\t\t * notes to sharpened ones. Optional, default false.\n\t\t * @returns {string} The resulting symbolic note name.\n\t\t */\n\t\tnoteFromMidiPitch: function(n, returnFlattened) {\n\t\t\tvar octave = 0, noteNum = n, noteName, returnFlattened = returnFlattened || false;\n\t\t\tif (n > 23) {\n\t\t\t\t// noteNum is on octave 1 or more\n\t\t\t\toctave = Math.floor(n/12) - 1;\n\t\t\t\t// subtract number of octaves from noteNum\n\t\t\t\tnoteNum = n - octave * 12;\n\t\t\t}\n\n\t\t\t// get note name (c#, d, f# etc)\n\t\t\tnoteName = Util.midi_pitches_letter[noteNum];\n\t\t\t// Use flattened notes if requested (e.g. f# should be output as gb)\n\t\t\tif (returnFlattened && noteName.indexOf('#') > 0) {\n\t\t\t\tnoteName = Util.midi_flattened_notes[noteName];\n\t\t\t}\n\t\t\treturn noteName + octave;\n\t\t},\n\n\t\t/**\n\t\t * Convert beats per minute (BPM) to microseconds per quarter note (MPQN).\n\t\t *\n\t\t * @param {number} bpm - A number in beats per minute.\n\t\t * @returns {number} The number of microseconds per quarter note.\n\t\t */\n\t\tmpqnFromBpm: function(bpm) {\n\t\t\tvar mpqn = Math.floor(60000000 / bpm);\n\t\t\tvar ret=[];\n\t\t\tdo {\n\t\t\t\tret.unshift(mpqn & 0xFF);\n\t\t\t\tmpqn >>= 8;\n\t\t\t} while (mpqn);\n\t\t\twhile (ret.length < 3) {\n\t\t\t\tret.push(0);\n\t\t\t}\n\t\t\treturn ret;\n\t\t},\n\n\t\t/**\n\t\t * Convert microseconds per quarter note (MPQN) to beats per minute (BPM).\n\t\t *\n\t\t * @param {number} mpqn - The number of microseconds per quarter note.\n\t\t * @returns {number} A number in beats per minute.\n\t\t */\n\t\tbpmFromMpqn: function(mpqn) {\n\t\t\tvar m = mpqn;\n\t\t\tif (typeof mpqn[0] != 'undefined') {\n\t\t\t\tm = 0;\n\t\t\t\tfor (var i=0, l=mpqn.length-1; l >= 0; ++i, --l) {\n\t\t\t\t\tm |= mpqn[i] << l;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Math.floor(60000000 / mpqn);\n\t\t},\n\n\t\t/**\n\t\t * Converts an array of bytes to a string of hexadecimal characters. Prepares\n\t\t * it to be converted into a base64 string.\n\t\t *\n\t\t * @param {Array} byteArray - Array of bytes to be converted.\n\t\t * @returns {string} Hexadecimal string, e.g. \"097B8A\".\n\t\t */\n\t\tcodes2Str: function(byteArray) {\n\t\t\treturn String.fromCharCode.apply(null, byteArray);\n\t\t},\n\n\t\t/**\n\t\t * Converts a string of hexadecimal values to an array of bytes. It can also\n\t\t * add remaining \"0\" nibbles in order to have enough bytes in the array as the\n\t\t * `finalBytes` parameter.\n\t\t *\n\t\t * @param {string} str - string of hexadecimal values e.g. \"097B8A\"\n\t\t * @param {number} [finalBytes] - Optional. The desired number of bytes\n\t\t * (not nibbles) that the returned array should contain.\n\t\t * @returns {Array} An array of nibbles.\n\t\t */\n\t\tstr2Bytes: function (str, finalBytes) {\n\t\t\tif (finalBytes) {\n\t\t\t\twhile ((str.length / 2) < finalBytes) { str = \"0\" + str; }\n\t\t\t}\n\n\t\t\tvar bytes = [];\n\t\t\tfor (var i=str.length-1; i>=0; i = i-2) {\n\t\t\t\tvar chars = i === 0 ? str[i] : str[i-1] + str[i];\n\t\t\t\tbytes.unshift(parseInt(chars, 16));\n\t\t\t}\n\n\t\t\treturn bytes;\n\t\t},\n\n\t\t/**\n\t\t * Translates number of ticks to MIDI timestamp format, returning an array\n\t\t * of bytes with the time values. MIDI has a very particular way to express\n\t\t * time; take a good look at the spec before ever touching this function.\n\t\t *\n\t\t * @param {number} ticks - Number of ticks to be translated.\n\t\t * @returns {number} Array of bytes that form the MIDI time value.\n\t\t */\n\t\ttranslateTickTime: function(ticks) {\n\t\t\tvar buffer = ticks & 0x7F;\n\n\t\t\twhile (ticks = ticks >> 7) {\n\t\t\t\tbuffer <<= 8;\n\t\t\t\tbuffer |= ((ticks & 0x7F) | 0x80);\n\t\t\t}\n\n\t\t\tvar bList = [];\n\t\t\twhile (true) {\n\t\t\t\tbList.push(buffer & 0xff);\n\n\t\t\t\tif (buffer & 0x80) { buffer >>= 8; }\n\t\t\t\telse { break; }\n\t\t\t}\n\t\t\treturn bList;\n\t\t},\n\n\t};\n\n\t/* ******************************************************************\n\t * Event class\n\t ****************************************************************** */\n\n\t/**\n\t * Construct a MIDI event.\n\t *\n\t * Parameters include:\n\t *  - time [optional number] - Ticks since previous event.\n\t *  - type [required number] - Type of event.\n\t *  - channel [required number] - Channel for the event.\n\t *  - param1 [required number] - First event parameter.\n\t *  - param2 [optional number] - Second event parameter.\n\t */\n\tvar MidiEvent = function(params) {\n\t\tif (!this) return new MidiEvent(params);\n\t\tif (params &&\n\t\t\t\t(params.type    !== null || params.type    !== undefined) &&\n\t\t\t\t(params.channel !== null || params.channel !== undefined) &&\n\t\t\t\t(params.param1  !== null || params.param1  !== undefined)) {\n\t\t\tthis.setTime(params.time);\n\t\t\tthis.setType(params.type);\n\t\t\tthis.setChannel(params.channel);\n\t\t\tthis.setParam1(params.param1);\n\t\t\tthis.setParam2(params.param2);\n\t\t}\n\t};\n\n\t// event codes\n\tMidiEvent.NOTE_OFF           = 0x80;\n\tMidiEvent.NOTE_ON            = 0x90;\n\tMidiEvent.AFTER_TOUCH        = 0xA0;\n\tMidiEvent.CONTROLLER         = 0xB0;\n\tMidiEvent.PROGRAM_CHANGE     = 0xC0;\n\tMidiEvent.CHANNEL_AFTERTOUCH = 0xD0;\n\tMidiEvent.PITCH_BEND         = 0xE0;\n\n\n\t/**\n\t * Set the time for the event in ticks since the previous event.\n\t *\n\t * @param {number} ticks - The number of ticks since the previous event. May\n\t * be zero.\n\t */\n\tMidiEvent.prototype.setTime = function(ticks) {\n\t\tthis.time = Util.translateTickTime(ticks || 0);\n\t};\n\n\t/**\n\t * Set the type of the event. Must be one of the event codes on MidiEvent.\n\t *\n\t * @param {number} type - Event type.\n\t */\n\tMidiEvent.prototype.setType = function(type) {\n\t\tif (type < MidiEvent.NOTE_OFF || type > MidiEvent.PITCH_BEND) {\n\t\t\tthrow new Error(\"Trying to set an unknown event: \" + type);\n\t\t}\n\n\t\tthis.type = type;\n\t};\n\n\t/**\n\t * Set the channel for the event. Must be between 0 and 15, inclusive.\n\t *\n\t * @param {number} channel - The event channel.\n\t */\n\tMidiEvent.prototype.setChannel = function(channel) {\n\t\tif (channel < 0 || channel > 15) {\n\t\t\tthrow new Error(\"Channel is out of bounds.\");\n\t\t}\n\n\t\tthis.channel = channel;\n\t};\n\n\t/**\n\t * Set the first parameter for the event. Must be between 0 and 255,\n\t * inclusive.\n\t *\n\t * @param {number} p - The first event parameter value.\n\t */\n\tMidiEvent.prototype.setParam1 = function(p) {\n\t\tthis.param1 = p;\n\t};\n\n\t/**\n\t * Set the second parameter for the event. Must be between 0 and 255,\n\t * inclusive.\n\t *\n\t * @param {number} p - The second event parameter value.\n\t */\n\tMidiEvent.prototype.setParam2 = function(p) {\n\t\tthis.param2 = p;\n\t};\n\n\t/**\n\t * Serialize the event to an array of bytes.\n\t *\n\t * @returns {Array} The array of serialized bytes.\n\t */\n\tMidiEvent.prototype.toBytes = function() {\n\t\tvar byteArray = [];\n\n\t\tvar typeChannelByte = this.type | (this.channel & 0xF);\n\n\t\tbyteArray.push.apply(byteArray, this.time);\n\t\tbyteArray.push(typeChannelByte);\n\t\tbyteArray.push(this.param1);\n\n\t\t// Some events don't have a second parameter\n\t\tif (this.param2 !== undefined && this.param2 !== null) {\n\t\t\tbyteArray.push(this.param2);\n\t\t}\n\t\treturn byteArray;\n\t};\n\n\t/* ******************************************************************\n\t * MetaEvent class\n\t ****************************************************************** */\n\n\t/**\n\t * Construct a meta event.\n\t *\n\t * Parameters include:\n\t *  - time [optional number] - Ticks since previous event.\n\t *  - type [required number] - Type of event.\n\t *  - data [optional array|string] - Event data.\n\t */\n\tvar MetaEvent = function(params) {\n\t\tif (!this) return new MetaEvent(params);\n\t\tvar p = params || {};\n\t\tthis.setTime(params.time);\n\t\tthis.setType(params.type);\n\t\tthis.setData(params.data);\n\t};\n\n\tMetaEvent.SEQUENCE   = 0x00;\n\tMetaEvent.TEXT       = 0x01;\n\tMetaEvent.COPYRIGHT  = 0x02;\n\tMetaEvent.TRACK_NAME = 0x03;\n\tMetaEvent.INSTRUMENT = 0x04;\n\tMetaEvent.LYRIC      = 0x05;\n\tMetaEvent.MARKER     = 0x06;\n\tMetaEvent.CUE_POINT  = 0x07;\n\tMetaEvent.CHANNEL_PREFIX = 0x20;\n\tMetaEvent.END_OF_TRACK   = 0x2f;\n\tMetaEvent.TEMPO      = 0x51;\n\tMetaEvent.SMPTE      = 0x54;\n\tMetaEvent.TIME_SIG   = 0x58;\n\tMetaEvent.KEY_SIG    = 0x59;\n\tMetaEvent.SEQ_EVENT  = 0x7f;\n\n\t/**\n\t * Set the time for the event in ticks since the previous event.\n\t *\n\t * @param {number} ticks - The number of ticks since the previous event. May\n\t * be zero.\n\t */\n\tMetaEvent.prototype.setTime = function(ticks) {\n\t\tthis.time = Util.translateTickTime(ticks || 0);\n\t};\n\n\t/**\n\t * Set the type of the event. Must be one of the event codes on MetaEvent.\n\t *\n\t * @param {number} t - Event type.\n\t */\n\tMetaEvent.prototype.setType = function(t) {\n\t\tthis.type = t;\n\t};\n\n\t/**\n\t * Set the data associated with the event. May be a string or array of byte\n\t * values.\n\t *\n\t * @param {string|Array} d - Event data.\n\t */\n\tMetaEvent.prototype.setData = function(d) {\n\t\tthis.data = d;\n\t};\n\n\t/**\n\t * Serialize the event to an array of bytes.\n\t *\n\t * @returns {Array} The array of serialized bytes.\n\t */\n\tMetaEvent.prototype.toBytes = function() {\n\t\tif (!this.type) {\n\t\t\tthrow new Error(\"Type for meta-event not specified.\");\n\t\t}\n\n\t\tvar byteArray = [];\n\t\tbyteArray.push.apply(byteArray, this.time);\n\t\tbyteArray.push(0xFF, this.type);\n\n\t\t// If data is an array, we assume that it contains several bytes. We\n\t\t// apend them to byteArray.\n\t\tif (Array.isArray(this.data)) {\n\t\t\tbyteArray.push(this.data.length);\n\t\t\tbyteArray.push.apply(byteArray, this.data);\n\t\t} else if (typeof this.data == 'number') {\n\t\t\tbyteArray.push(1, this.data);\n\t\t} else if (this.data !== null && this.data !== undefined) {\n\t\t\t// assume string; may be a bad assumption\n\t\t\tbyteArray.push(this.data.length);\n\t\t\tvar dataBytes = this.data.split('').map(function(x){ return x.charCodeAt(0) });\n\t\t\tbyteArray.push.apply(byteArray, dataBytes);\n\t\t} else {\n\t\t\tbyteArray.push(0);\n\t\t}\n\n\t\treturn byteArray;\n\t};\n\n\t/* ******************************************************************\n\t * Track class\n\t ****************************************************************** */\n\n\t/**\n\t * Construct a MIDI track.\n\t *\n\t * Parameters include:\n\t *  - events [optional array] - Array of events for the track.\n\t */\n\tvar Track = function(config) {\n\t\tif (!this) return new Track(config);\n\t\tvar c = config || {};\n\t\tthis.events = c.events || [];\n\t};\n\n\tTrack.START_BYTES = [0x4d, 0x54, 0x72, 0x6b];\n\tTrack.END_BYTES   = [0x00, 0xFF, 0x2F, 0x00];\n\n\t/**\n\t * Add an event to the track.\n\t *\n\t * @param {MidiEvent|MetaEvent} event - The event to add.\n\t * @returns {Track} The current track.\n\t */\n\tTrack.prototype.addEvent = function(event) {\n\t\tthis.events.push(event);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Add a note-on event to the track.\n\t *\n\t * @param {number} channel - The channel to add the event to.\n\t * @param {number|string} pitch - The pitch of the note, either numeric or\n\t * symbolic.\n\t * @param {number} [time=0] - The number of ticks since the previous event,\n\t * defaults to 0.\n\t * @param {number} [velocity=90] - The volume for the note, defaults to\n\t * DEFAULT_VOLUME.\n\t * @returns {Track} The current track.\n\t */\n\tTrack.prototype.addNoteOn = Track.prototype.noteOn = function(channel, pitch, time, velocity) {\n\t\tthis.events.push(new MidiEvent({\n\t\t\ttype: MidiEvent.NOTE_ON,\n\t\t\tchannel: channel,\n\t\t\tparam1: Util.ensureMidiPitch(pitch),\n\t\t\tparam2: velocity || DEFAULT_VOLUME,\n\t\t\ttime: time || 0,\n\t\t}));\n\t\treturn this;\n\t};\n\n\t/**\n\t * Add a note-off event to the track.\n\t *\n\t * @param {number} channel - The channel to add the event to.\n\t * @param {number|string} pitch - The pitch of the note, either numeric or\n\t * symbolic.\n\t * @param {number} [time=0] - The number of ticks since the previous event,\n\t * defaults to 0.\n\t * @param {number} [velocity=90] - The velocity the note was released,\n\t * defaults to DEFAULT_VOLUME.\n\t * @returns {Track} The current track.\n\t */\n\tTrack.prototype.addNoteOff = Track.prototype.noteOff = function(channel, pitch, time, velocity) {\n\t\tthis.events.push(new MidiEvent({\n\t\t\ttype: MidiEvent.NOTE_OFF,\n\t\t\tchannel: channel,\n\t\t\tparam1: Util.ensureMidiPitch(pitch),\n\t\t\tparam2: velocity || DEFAULT_VOLUME,\n\t\t\ttime: time || 0,\n\t\t}));\n\t\treturn this;\n\t};\n\n\t/**\n\t * Add a note-on and -off event to the track.\n\t *\n\t * @param {number} channel - The channel to add the event to.\n\t * @param {number|string} pitch - The pitch of the note, either numeric or\n\t * symbolic.\n\t * @param {number} dur - The duration of the note, in ticks.\n\t * @param {number} [time=0] - The number of ticks since the previous event,\n\t * defaults to 0.\n\t * @param {number} [velocity=90] - The velocity the note was released,\n\t * defaults to DEFAULT_VOLUME.\n\t * @returns {Track} The current track.\n\t */\n\tTrack.prototype.addNote = Track.prototype.note = function(channel, pitch, dur, time, velocity) {\n\t\tthis.noteOn(channel, pitch, time, velocity);\n\t\tif (dur) {\n\t\t\tthis.noteOff(channel, pitch, dur, velocity);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Add a note-on and -off event to the track for each pitch in an array of pitches.\n\t *\n\t * @param {number} channel - The channel to add the event to.\n\t * @param {array} chord - An array of pitches, either numeric or\n\t * symbolic.\n\t * @param {number} dur - The duration of the chord, in ticks.\n\t * @param {number} [velocity=90] - The velocity of the chord,\n\t * defaults to DEFAULT_VOLUME.\n\t * @returns {Track} The current track.\n\t */\n\tTrack.prototype.addChord = Track.prototype.chord = function(channel, chord, dur, velocity) {\n\t\tif (!Array.isArray(chord) && !chord.length) {\n\t\t\tthrow new Error('Chord must be an array of pitches');\n\t\t}\n\t\tchord.forEach(function(note) {\n\t\t\tthis.noteOn(channel, note, 0, velocity);\n\t\t}, this);\n\t\tchord.forEach(function(note, index) {\n\t\t\tif (index === 0) {\n\t\t\t\tthis.noteOff(channel, note, dur);\n\t\t\t} else {\n\t\t\t\tthis.noteOff(channel, note);\n\t\t\t}\n\t\t}, this);\n\t\treturn this;\n\t};\n\n\t/**\n\t * Set instrument for the track.\n\t *\n\t * @param {number} channel - The channel to set the instrument on.\n\t * @param {number} instrument - The instrument to set it to.\n\t * @param {number} [time=0] - The number of ticks since the previous event,\n\t * defaults to 0.\n\t * @returns {Track} The current track.\n\t */\n\tTrack.prototype.setInstrument = Track.prototype.instrument = function(channel, instrument, time) {\n\t\tthis.events.push(new MidiEvent({\n\t\t\ttype: MidiEvent.PROGRAM_CHANGE,\n\t\t\tchannel: channel,\n\t\t\tparam1: instrument,\n\t\t\ttime: time || 0,\n\t\t}));\n\t\treturn this;\n\t};\n\n\t/**\n\t * Set the tempo for the track.\n\t *\n\t * @param {number} bpm - The new number of beats per minute.\n\t * @param {number} [time=0] - The number of ticks since the previous event,\n\t * defaults to 0.\n\t * @returns {Track} The current track.\n\t */\n\tTrack.prototype.setTempo = Track.prototype.tempo = function(bpm, time) {\n\t\tthis.events.push(new MetaEvent({\n\t\t\ttype: MetaEvent.TEMPO,\n\t\t\tdata: Util.mpqnFromBpm(bpm),\n\t\t\ttime: time || 0,\n\t\t}));\n\t\treturn this;\n\t};\n\n\t/**\n\t * Serialize the track to an array of bytes.\n\t *\n\t * @returns {Array} The array of serialized bytes.\n\t */\n\tTrack.prototype.toBytes = function() {\n\t\tvar trackLength = 0;\n\t\tvar eventBytes = [];\n\t\tvar startBytes = Track.START_BYTES;\n\t\tvar endBytes   = Track.END_BYTES;\n\n\t\tvar addEventBytes = function(event) {\n\t\t\tvar bytes = event.toBytes();\n\t\t\ttrackLength += bytes.length;\n\t\t\teventBytes.push.apply(eventBytes, bytes);\n\t\t};\n\n\t\tthis.events.forEach(addEventBytes);\n\n\t\t// Add the end-of-track bytes to the sum of bytes for the track, since\n\t\t// they are counted (unlike the start-of-track ones).\n\t\ttrackLength += endBytes.length;\n\n\t\t// Makes sure that track length will fill up 4 bytes with 0s in case\n\t\t// the length is less than that (the usual case).\n\t\tvar lengthBytes = Util.str2Bytes(trackLength.toString(16), 4);\n\n\t\treturn startBytes.concat(lengthBytes, eventBytes, endBytes);\n\t};\n\n\t/* ******************************************************************\n\t * File class\n\t ****************************************************************** */\n\n\t/**\n\t * Construct a file object.\n\t *\n\t * Parameters include:\n\t *  - ticks [optional number] - Number of ticks per beat, defaults to 128.\n\t *    Must be 1-32767.\n\t *  - tracks [optional array] - Track data.\n\t */\n\tvar File = function(config){\n\t\tif (!this) return new File(config);\n\n\t\tvar c = config || {};\n\t\tif (c.ticks) {\n\t\t\tif (typeof c.ticks !== 'number') {\n\t\t\t\tthrow new Error('Ticks per beat must be a number!');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (c.ticks <= 0 || c.ticks >= (1 << 15) || c.ticks % 1 !== 0) {\n\t\t\t\tthrow new Error('Ticks per beat must be an integer between 1 and 32767!');\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.ticks = c.ticks || 128;\n\t\tthis.tracks = c.tracks || [];\n\t};\n\n\tFile.HDR_CHUNKID     = \"MThd\";             // File magic cookie\n\tFile.HDR_CHUNK_SIZE  = \"\\x00\\x00\\x00\\x06\"; // Header length for SMF\n\tFile.HDR_TYPE0       = \"\\x00\\x00\";         // Midi Type 0 id\n\tFile.HDR_TYPE1       = \"\\x00\\x01\";         // Midi Type 1 id\n\n\t/**\n\t * Add a track to the file.\n\t *\n\t * @param {Track} track - The track to add.\n\t */\n\tFile.prototype.addTrack = function(track) {\n\t\tif (track) {\n\t\t\tthis.tracks.push(track);\n\t\t\treturn this;\n\t\t} else {\n\t\t\ttrack = new Track();\n\t\t\tthis.tracks.push(track);\n\t\t\treturn track;\n\t\t}\n\t};\n\n\t/**\n\t * Serialize the MIDI file to an array of bytes.\n\t *\n\t * @returns {Array} The array of serialized bytes.\n\t */\n\tFile.prototype.toBytes = function() {\n\t\tvar trackCount = this.tracks.length.toString(16);\n\n\t\t// prepare the file header\n\t\tvar bytes = File.HDR_CHUNKID + File.HDR_CHUNK_SIZE;\n\n\t\t// set Midi type based on number of tracks\n\t\tif (parseInt(trackCount, 16) > 1) {\n\t\t\tbytes += File.HDR_TYPE1;\n\t\t} else {\n\t\t\tbytes += File.HDR_TYPE0;\n\t\t}\n\n\t\t// add the number of tracks (2 bytes)\n\t\tbytes += Util.codes2Str(Util.str2Bytes(trackCount, 2));\n\t\t// add the number of ticks per beat (currently hardcoded)\n\t\tbytes += String.fromCharCode((this.ticks/256),  this.ticks%256);;\n\n\t\t// iterate over the tracks, converting to bytes too\n\t\tthis.tracks.forEach(function(track) {\n\t\t\tbytes += Util.codes2Str(track.toBytes());\n\t\t});\n\n\t\treturn bytes;\n\t};\n\n\t/* ******************************************************************\n\t * Exports\n\t ****************************************************************** */\n\n\texported.Util = Util;\n\texported.File = File;\n\texported.Track = Track;\n\texported.Event = MidiEvent;\n\texported.MetaEvent = MetaEvent;\n\n})( Midi );\n\nif (typeof module != 'undefined' && module !== null) {\n\tmodule.exports = Midi;\n} else if (typeof exports != 'undefined' && exports !== null) {\n\texports = Midi;\n} else {\n\tthis.Midi = Midi;\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)(module)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzbWlkZ2VuL2xpYi9qc21pZGdlbi5qcz9iOWEyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLDJDQUEyQzs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCx3QkFBd0IsOEhBQThIO0FBQ3RKLHlCQUF5Qix3REFBd0Q7O0FBRWpGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0IsMkNBQTJDO0FBQzNDLG1DQUFtQztBQUNuQyxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIE1pZGkgPSB7fTtcblxuKGZ1bmN0aW9uKGV4cG9ydGVkKSB7XG5cblx0dmFyIERFRkFVTFRfVk9MVU1FICAgPSBleHBvcnRlZC5ERUZBVUxUX1ZPTFVNRSAgID0gOTA7XG5cdHZhciBERUZBVUxUX0RVUkFUSU9OID0gZXhwb3J0ZWQuREVGQVVMVF9EVVJBVElPTiA9IDEyODtcblx0dmFyIERFRkFVTFRfQ0hBTk5FTCAgPSBleHBvcnRlZC5ERUZBVUxUX0NIQU5ORUwgID0gMDtcblxuXHQvKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ICogVXRpbGl0eSBmdW5jdGlvbnNcblx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5cdHZhciBVdGlsID0ge1xuXG5cdFx0bWlkaV9sZXR0ZXJfcGl0Y2hlczogeyBhOjIxLCBiOjIzLCBjOjEyLCBkOjE0LCBlOjE2LCBmOjE3LCBnOjE5IH0sXG5cblx0XHQvKipcblx0XHQgKiBDb252ZXJ0IGEgc3ltYm9saWMgbm90ZSBuYW1lIChlLmcuIFwiYzRcIikgdG8gYSBudW1lcmljIE1JREkgcGl0Y2ggKGUuZy5cblx0XHQgKiA2MCwgbWlkZGxlIEMpLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IG4gLSBUaGUgc3ltYm9saWMgbm90ZSBuYW1lIHRvIHBhcnNlLlxuXHRcdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBNSURJIHBpdGNoIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHN5bWJvbGljIG5vdGVcblx0XHQgKiBuYW1lLlxuXHRcdCAqL1xuXHRcdG1pZGlQaXRjaEZyb21Ob3RlOiBmdW5jdGlvbihuKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyA9IC8oW2EtZ10pKCMrfGIrKT8oWzAtOV0rKSQvaS5leGVjKG4pO1xuXHRcdFx0dmFyIG5vdGUgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKCksIGFjY2lkZW50YWwgPSBtYXRjaGVzWzJdIHx8ICcnLCBvY3RhdmUgPSBwYXJzZUludChtYXRjaGVzWzNdLCAxMCk7XG5cdFx0XHRyZXR1cm4gKDEyICogb2N0YXZlKSArIFV0aWwubWlkaV9sZXR0ZXJfcGl0Y2hlc1tub3RlXSArIChhY2NpZGVudGFsLnN1YnN0cigwLDEpPT0nIyc/MTotMSkgKiBhY2NpZGVudGFsLmxlbmd0aDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRW5zdXJlIHRoYXQgdGhlIGdpdmVuIGFyZ3VtZW50IGlzIGNvbnZlcnRlZCB0byBhIE1JREkgcGl0Y2guIE5vdGUgdGhhdFxuXHRcdCAqIGl0IG1heSBhbHJlYWR5IGJlIG9uZSAoaW5jbHVkaW5nIGEgcHVyZWx5IG51bWVyaWMgc3RyaW5nKS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gcCAtIFRoZSBwaXRjaCB0byBjb252ZXJ0LlxuXHRcdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByZXN1bHRpbmcgbnVtZXJpYyBNSURJIHBpdGNoLlxuXHRcdCAqL1xuXHRcdGVuc3VyZU1pZGlQaXRjaDogZnVuY3Rpb24ocCkge1xuXHRcdFx0aWYgKHR5cGVvZiBwID09ICdudW1iZXInIHx8ICEvW14wLTldLy50ZXN0KHApKSB7XG5cdFx0XHRcdC8vIG51bWVyaWMgcGl0Y2hcblx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KHAsIDEwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGFzc3VtZSBpdCdzIGEgbm90ZSBuYW1lXG5cdFx0XHRcdHJldHVybiBVdGlsLm1pZGlQaXRjaEZyb21Ob3RlKHApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRtaWRpX3BpdGNoZXNfbGV0dGVyOiB7ICcxMic6J2MnLCAnMTMnOidjIycsICcxNCc6J2QnLCAnMTUnOidkIycsICcxNic6J2UnLCAnMTcnOidmJywgJzE4JzonZiMnLCAnMTknOidnJywgJzIwJzonZyMnLCAnMjEnOidhJywgJzIyJzonYSMnLCAnMjMnOidiJyB9LFxuXHRcdG1pZGlfZmxhdHRlbmVkX25vdGVzOiB7ICdhIyc6J2JiJywgJ2MjJzonZGInLCAnZCMnOidlYicsICdmIyc6J2diJywgJ2cjJzonYWInIH0sXG5cblx0XHQvKipcblx0XHQgKiBDb252ZXJ0IGEgbnVtZXJpYyBNSURJIHBpdGNoIHZhbHVlIChlLmcuIDYwKSB0byBhIHN5bWJvbGljIG5vdGUgbmFtZVxuXHRcdCAqIChlLmcuIFwiYzRcIikuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBudW1lcmljIE1JREkgcGl0Y2ggdmFsdWUgdG8gY29udmVydC5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXR1cm5GbGF0dGVuZWQ9ZmFsc2VdIC0gV2hldGhlciB0byBwcmVmZXIgZmxhdHRlbmVkXG5cdFx0ICogbm90ZXMgdG8gc2hhcnBlbmVkIG9uZXMuIE9wdGlvbmFsLCBkZWZhdWx0IGZhbHNlLlxuXHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSByZXN1bHRpbmcgc3ltYm9saWMgbm90ZSBuYW1lLlxuXHRcdCAqL1xuXHRcdG5vdGVGcm9tTWlkaVBpdGNoOiBmdW5jdGlvbihuLCByZXR1cm5GbGF0dGVuZWQpIHtcblx0XHRcdHZhciBvY3RhdmUgPSAwLCBub3RlTnVtID0gbiwgbm90ZU5hbWUsIHJldHVybkZsYXR0ZW5lZCA9IHJldHVybkZsYXR0ZW5lZCB8fCBmYWxzZTtcblx0XHRcdGlmIChuID4gMjMpIHtcblx0XHRcdFx0Ly8gbm90ZU51bSBpcyBvbiBvY3RhdmUgMSBvciBtb3JlXG5cdFx0XHRcdG9jdGF2ZSA9IE1hdGguZmxvb3Iobi8xMikgLSAxO1xuXHRcdFx0XHQvLyBzdWJ0cmFjdCBudW1iZXIgb2Ygb2N0YXZlcyBmcm9tIG5vdGVOdW1cblx0XHRcdFx0bm90ZU51bSA9IG4gLSBvY3RhdmUgKiAxMjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZ2V0IG5vdGUgbmFtZSAoYyMsIGQsIGYjIGV0Yylcblx0XHRcdG5vdGVOYW1lID0gVXRpbC5taWRpX3BpdGNoZXNfbGV0dGVyW25vdGVOdW1dO1xuXHRcdFx0Ly8gVXNlIGZsYXR0ZW5lZCBub3RlcyBpZiByZXF1ZXN0ZWQgKGUuZy4gZiMgc2hvdWxkIGJlIG91dHB1dCBhcyBnYilcblx0XHRcdGlmIChyZXR1cm5GbGF0dGVuZWQgJiYgbm90ZU5hbWUuaW5kZXhPZignIycpID4gMCkge1xuXHRcdFx0XHRub3RlTmFtZSA9IFV0aWwubWlkaV9mbGF0dGVuZWRfbm90ZXNbbm90ZU5hbWVdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5vdGVOYW1lICsgb2N0YXZlO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDb252ZXJ0IGJlYXRzIHBlciBtaW51dGUgKEJQTSkgdG8gbWljcm9zZWNvbmRzIHBlciBxdWFydGVyIG5vdGUgKE1QUU4pLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IGJwbSAtIEEgbnVtYmVyIGluIGJlYXRzIHBlciBtaW51dGUuXG5cdFx0ICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBtaWNyb3NlY29uZHMgcGVyIHF1YXJ0ZXIgbm90ZS5cblx0XHQgKi9cblx0XHRtcHFuRnJvbUJwbTogZnVuY3Rpb24oYnBtKSB7XG5cdFx0XHR2YXIgbXBxbiA9IE1hdGguZmxvb3IoNjAwMDAwMDAgLyBicG0pO1xuXHRcdFx0dmFyIHJldD1bXTtcblx0XHRcdGRvIHtcblx0XHRcdFx0cmV0LnVuc2hpZnQobXBxbiAmIDB4RkYpO1xuXHRcdFx0XHRtcHFuID4+PSA4O1xuXHRcdFx0fSB3aGlsZSAobXBxbik7XG5cdFx0XHR3aGlsZSAocmV0Lmxlbmd0aCA8IDMpIHtcblx0XHRcdFx0cmV0LnB1c2goMCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDb252ZXJ0IG1pY3Jvc2Vjb25kcyBwZXIgcXVhcnRlciBub3RlIChNUFFOKSB0byBiZWF0cyBwZXIgbWludXRlIChCUE0pLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IG1wcW4gLSBUaGUgbnVtYmVyIG9mIG1pY3Jvc2Vjb25kcyBwZXIgcXVhcnRlciBub3RlLlxuXHRcdCAqIEByZXR1cm5zIHtudW1iZXJ9IEEgbnVtYmVyIGluIGJlYXRzIHBlciBtaW51dGUuXG5cdFx0ICovXG5cdFx0YnBtRnJvbU1wcW46IGZ1bmN0aW9uKG1wcW4pIHtcblx0XHRcdHZhciBtID0gbXBxbjtcblx0XHRcdGlmICh0eXBlb2YgbXBxblswXSAhPSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRtID0gMDtcblx0XHRcdFx0Zm9yICh2YXIgaT0wLCBsPW1wcW4ubGVuZ3RoLTE7IGwgPj0gMDsgKytpLCAtLWwpIHtcblx0XHRcdFx0XHRtIHw9IG1wcW5baV0gPDwgbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoNjAwMDAwMDAgLyBtcHFuKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ29udmVydHMgYW4gYXJyYXkgb2YgYnl0ZXMgdG8gYSBzdHJpbmcgb2YgaGV4YWRlY2ltYWwgY2hhcmFjdGVycy4gUHJlcGFyZXNcblx0XHQgKiBpdCB0byBiZSBjb252ZXJ0ZWQgaW50byBhIGJhc2U2NCBzdHJpbmcuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBieXRlQXJyYXkgLSBBcnJheSBvZiBieXRlcyB0byBiZSBjb252ZXJ0ZWQuXG5cdFx0ICogQHJldHVybnMge3N0cmluZ30gSGV4YWRlY2ltYWwgc3RyaW5nLCBlLmcuIFwiMDk3QjhBXCIuXG5cdFx0ICovXG5cdFx0Y29kZXMyU3RyOiBmdW5jdGlvbihieXRlQXJyYXkpIHtcblx0XHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVBcnJheSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIGhleGFkZWNpbWFsIHZhbHVlcyB0byBhbiBhcnJheSBvZiBieXRlcy4gSXQgY2FuIGFsc29cblx0XHQgKiBhZGQgcmVtYWluaW5nIFwiMFwiIG5pYmJsZXMgaW4gb3JkZXIgdG8gaGF2ZSBlbm91Z2ggYnl0ZXMgaW4gdGhlIGFycmF5IGFzIHRoZVxuXHRcdCAqIGBmaW5hbEJ5dGVzYCBwYXJhbWV0ZXIuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gc3RyaW5nIG9mIGhleGFkZWNpbWFsIHZhbHVlcyBlLmcuIFwiMDk3QjhBXCJcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gW2ZpbmFsQnl0ZXNdIC0gT3B0aW9uYWwuIFRoZSBkZXNpcmVkIG51bWJlciBvZiBieXRlc1xuXHRcdCAqIChub3QgbmliYmxlcykgdGhhdCB0aGUgcmV0dXJuZWQgYXJyYXkgc2hvdWxkIGNvbnRhaW4uXG5cdFx0ICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiBuaWJibGVzLlxuXHRcdCAqL1xuXHRcdHN0cjJCeXRlczogZnVuY3Rpb24gKHN0ciwgZmluYWxCeXRlcykge1xuXHRcdFx0aWYgKGZpbmFsQnl0ZXMpIHtcblx0XHRcdFx0d2hpbGUgKChzdHIubGVuZ3RoIC8gMikgPCBmaW5hbEJ5dGVzKSB7IHN0ciA9IFwiMFwiICsgc3RyOyB9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBieXRlcyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaT1zdHIubGVuZ3RoLTE7IGk+PTA7IGkgPSBpLTIpIHtcblx0XHRcdFx0dmFyIGNoYXJzID0gaSA9PT0gMCA/IHN0cltpXSA6IHN0cltpLTFdICsgc3RyW2ldO1xuXHRcdFx0XHRieXRlcy51bnNoaWZ0KHBhcnNlSW50KGNoYXJzLCAxNikpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYnl0ZXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRyYW5zbGF0ZXMgbnVtYmVyIG9mIHRpY2tzIHRvIE1JREkgdGltZXN0YW1wIGZvcm1hdCwgcmV0dXJuaW5nIGFuIGFycmF5XG5cdFx0ICogb2YgYnl0ZXMgd2l0aCB0aGUgdGltZSB2YWx1ZXMuIE1JREkgaGFzIGEgdmVyeSBwYXJ0aWN1bGFyIHdheSB0byBleHByZXNzXG5cdFx0ICogdGltZTsgdGFrZSBhIGdvb2QgbG9vayBhdCB0aGUgc3BlYyBiZWZvcmUgZXZlciB0b3VjaGluZyB0aGlzIGZ1bmN0aW9uLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IHRpY2tzIC0gTnVtYmVyIG9mIHRpY2tzIHRvIGJlIHRyYW5zbGF0ZWQuXG5cdFx0ICogQHJldHVybnMge251bWJlcn0gQXJyYXkgb2YgYnl0ZXMgdGhhdCBmb3JtIHRoZSBNSURJIHRpbWUgdmFsdWUuXG5cdFx0ICovXG5cdFx0dHJhbnNsYXRlVGlja1RpbWU6IGZ1bmN0aW9uKHRpY2tzKSB7XG5cdFx0XHR2YXIgYnVmZmVyID0gdGlja3MgJiAweDdGO1xuXG5cdFx0XHR3aGlsZSAodGlja3MgPSB0aWNrcyA+PiA3KSB7XG5cdFx0XHRcdGJ1ZmZlciA8PD0gODtcblx0XHRcdFx0YnVmZmVyIHw9ICgodGlja3MgJiAweDdGKSB8IDB4ODApO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYkxpc3QgPSBbXTtcblx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdGJMaXN0LnB1c2goYnVmZmVyICYgMHhmZik7XG5cblx0XHRcdFx0aWYgKGJ1ZmZlciAmIDB4ODApIHsgYnVmZmVyID4+PSA4OyB9XG5cdFx0XHRcdGVsc2UgeyBicmVhazsgfVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJMaXN0O1xuXHRcdH0sXG5cblx0fTtcblxuXHQvKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ICogRXZlbnQgY2xhc3Ncblx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3QgYSBNSURJIGV2ZW50LlxuXHQgKlxuXHQgKiBQYXJhbWV0ZXJzIGluY2x1ZGU6XG5cdCAqICAtIHRpbWUgW29wdGlvbmFsIG51bWJlcl0gLSBUaWNrcyBzaW5jZSBwcmV2aW91cyBldmVudC5cblx0ICogIC0gdHlwZSBbcmVxdWlyZWQgbnVtYmVyXSAtIFR5cGUgb2YgZXZlbnQuXG5cdCAqICAtIGNoYW5uZWwgW3JlcXVpcmVkIG51bWJlcl0gLSBDaGFubmVsIGZvciB0aGUgZXZlbnQuXG5cdCAqICAtIHBhcmFtMSBbcmVxdWlyZWQgbnVtYmVyXSAtIEZpcnN0IGV2ZW50IHBhcmFtZXRlci5cblx0ICogIC0gcGFyYW0yIFtvcHRpb25hbCBudW1iZXJdIC0gU2Vjb25kIGV2ZW50IHBhcmFtZXRlci5cblx0ICovXG5cdHZhciBNaWRpRXZlbnQgPSBmdW5jdGlvbihwYXJhbXMpIHtcblx0XHRpZiAoIXRoaXMpIHJldHVybiBuZXcgTWlkaUV2ZW50KHBhcmFtcyk7XG5cdFx0aWYgKHBhcmFtcyAmJlxuXHRcdFx0XHQocGFyYW1zLnR5cGUgICAgIT09IG51bGwgfHwgcGFyYW1zLnR5cGUgICAgIT09IHVuZGVmaW5lZCkgJiZcblx0XHRcdFx0KHBhcmFtcy5jaGFubmVsICE9PSBudWxsIHx8IHBhcmFtcy5jaGFubmVsICE9PSB1bmRlZmluZWQpICYmXG5cdFx0XHRcdChwYXJhbXMucGFyYW0xICAhPT0gbnVsbCB8fCBwYXJhbXMucGFyYW0xICAhPT0gdW5kZWZpbmVkKSkge1xuXHRcdFx0dGhpcy5zZXRUaW1lKHBhcmFtcy50aW1lKTtcblx0XHRcdHRoaXMuc2V0VHlwZShwYXJhbXMudHlwZSk7XG5cdFx0XHR0aGlzLnNldENoYW5uZWwocGFyYW1zLmNoYW5uZWwpO1xuXHRcdFx0dGhpcy5zZXRQYXJhbTEocGFyYW1zLnBhcmFtMSk7XG5cdFx0XHR0aGlzLnNldFBhcmFtMihwYXJhbXMucGFyYW0yKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gZXZlbnQgY29kZXNcblx0TWlkaUV2ZW50Lk5PVEVfT0ZGICAgICAgICAgICA9IDB4ODA7XG5cdE1pZGlFdmVudC5OT1RFX09OICAgICAgICAgICAgPSAweDkwO1xuXHRNaWRpRXZlbnQuQUZURVJfVE9VQ0ggICAgICAgID0gMHhBMDtcblx0TWlkaUV2ZW50LkNPTlRST0xMRVIgICAgICAgICA9IDB4QjA7XG5cdE1pZGlFdmVudC5QUk9HUkFNX0NIQU5HRSAgICAgPSAweEMwO1xuXHRNaWRpRXZlbnQuQ0hBTk5FTF9BRlRFUlRPVUNIID0gMHhEMDtcblx0TWlkaUV2ZW50LlBJVENIX0JFTkQgICAgICAgICA9IDB4RTA7XG5cblxuXHQvKipcblx0ICogU2V0IHRoZSB0aW1lIGZvciB0aGUgZXZlbnQgaW4gdGlja3Mgc2luY2UgdGhlIHByZXZpb3VzIGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGlja3MgLSBUaGUgbnVtYmVyIG9mIHRpY2tzIHNpbmNlIHRoZSBwcmV2aW91cyBldmVudC4gTWF5XG5cdCAqIGJlIHplcm8uXG5cdCAqL1xuXHRNaWRpRXZlbnQucHJvdG90eXBlLnNldFRpbWUgPSBmdW5jdGlvbih0aWNrcykge1xuXHRcdHRoaXMudGltZSA9IFV0aWwudHJhbnNsYXRlVGlja1RpbWUodGlja3MgfHwgMCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgdHlwZSBvZiB0aGUgZXZlbnQuIE11c3QgYmUgb25lIG9mIHRoZSBldmVudCBjb2RlcyBvbiBNaWRpRXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIC0gRXZlbnQgdHlwZS5cblx0ICovXG5cdE1pZGlFdmVudC5wcm90b3R5cGUuc2V0VHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRpZiAodHlwZSA8IE1pZGlFdmVudC5OT1RFX09GRiB8fCB0eXBlID4gTWlkaUV2ZW50LlBJVENIX0JFTkQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlRyeWluZyB0byBzZXQgYW4gdW5rbm93biBldmVudDogXCIgKyB0eXBlKTtcblx0XHR9XG5cblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGNoYW5uZWwgZm9yIHRoZSBldmVudC4gTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDE1LCBpbmNsdXNpdmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjaGFubmVsIC0gVGhlIGV2ZW50IGNoYW5uZWwuXG5cdCAqL1xuXHRNaWRpRXZlbnQucHJvdG90eXBlLnNldENoYW5uZWwgPSBmdW5jdGlvbihjaGFubmVsKSB7XG5cdFx0aWYgKGNoYW5uZWwgPCAwIHx8IGNoYW5uZWwgPiAxNSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2hhbm5lbCBpcyBvdXQgb2YgYm91bmRzLlwiKTtcblx0XHR9XG5cblx0XHR0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGZpcnN0IHBhcmFtZXRlciBmb3IgdGhlIGV2ZW50LiBNdXN0IGJlIGJldHdlZW4gMCBhbmQgMjU1LFxuXHQgKiBpbmNsdXNpdmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwIC0gVGhlIGZpcnN0IGV2ZW50IHBhcmFtZXRlciB2YWx1ZS5cblx0ICovXG5cdE1pZGlFdmVudC5wcm90b3R5cGUuc2V0UGFyYW0xID0gZnVuY3Rpb24ocCkge1xuXHRcdHRoaXMucGFyYW0xID0gcDtcblx0fTtcblxuXHQvKipcblx0ICogU2V0IHRoZSBzZWNvbmQgcGFyYW1ldGVyIGZvciB0aGUgZXZlbnQuIE11c3QgYmUgYmV0d2VlbiAwIGFuZCAyNTUsXG5cdCAqIGluY2x1c2l2ZS5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHAgLSBUaGUgc2Vjb25kIGV2ZW50IHBhcmFtZXRlciB2YWx1ZS5cblx0ICovXG5cdE1pZGlFdmVudC5wcm90b3R5cGUuc2V0UGFyYW0yID0gZnVuY3Rpb24ocCkge1xuXHRcdHRoaXMucGFyYW0yID0gcDtcblx0fTtcblxuXHQvKipcblx0ICogU2VyaWFsaXplIHRoZSBldmVudCB0byBhbiBhcnJheSBvZiBieXRlcy5cblx0ICpcblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2Ygc2VyaWFsaXplZCBieXRlcy5cblx0ICovXG5cdE1pZGlFdmVudC5wcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBieXRlQXJyYXkgPSBbXTtcblxuXHRcdHZhciB0eXBlQ2hhbm5lbEJ5dGUgPSB0aGlzLnR5cGUgfCAodGhpcy5jaGFubmVsICYgMHhGKTtcblxuXHRcdGJ5dGVBcnJheS5wdXNoLmFwcGx5KGJ5dGVBcnJheSwgdGhpcy50aW1lKTtcblx0XHRieXRlQXJyYXkucHVzaCh0eXBlQ2hhbm5lbEJ5dGUpO1xuXHRcdGJ5dGVBcnJheS5wdXNoKHRoaXMucGFyYW0xKTtcblxuXHRcdC8vIFNvbWUgZXZlbnRzIGRvbid0IGhhdmUgYSBzZWNvbmQgcGFyYW1ldGVyXG5cdFx0aWYgKHRoaXMucGFyYW0yICE9PSB1bmRlZmluZWQgJiYgdGhpcy5wYXJhbTIgIT09IG51bGwpIHtcblx0XHRcdGJ5dGVBcnJheS5wdXNoKHRoaXMucGFyYW0yKTtcblx0XHR9XG5cdFx0cmV0dXJuIGJ5dGVBcnJheTtcblx0fTtcblxuXHQvKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ICogTWV0YUV2ZW50IGNsYXNzXG5cdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuXHQvKipcblx0ICogQ29uc3RydWN0IGEgbWV0YSBldmVudC5cblx0ICpcblx0ICogUGFyYW1ldGVycyBpbmNsdWRlOlxuXHQgKiAgLSB0aW1lIFtvcHRpb25hbCBudW1iZXJdIC0gVGlja3Mgc2luY2UgcHJldmlvdXMgZXZlbnQuXG5cdCAqICAtIHR5cGUgW3JlcXVpcmVkIG51bWJlcl0gLSBUeXBlIG9mIGV2ZW50LlxuXHQgKiAgLSBkYXRhIFtvcHRpb25hbCBhcnJheXxzdHJpbmddIC0gRXZlbnQgZGF0YS5cblx0ICovXG5cdHZhciBNZXRhRXZlbnQgPSBmdW5jdGlvbihwYXJhbXMpIHtcblx0XHRpZiAoIXRoaXMpIHJldHVybiBuZXcgTWV0YUV2ZW50KHBhcmFtcyk7XG5cdFx0dmFyIHAgPSBwYXJhbXMgfHwge307XG5cdFx0dGhpcy5zZXRUaW1lKHBhcmFtcy50aW1lKTtcblx0XHR0aGlzLnNldFR5cGUocGFyYW1zLnR5cGUpO1xuXHRcdHRoaXMuc2V0RGF0YShwYXJhbXMuZGF0YSk7XG5cdH07XG5cblx0TWV0YUV2ZW50LlNFUVVFTkNFICAgPSAweDAwO1xuXHRNZXRhRXZlbnQuVEVYVCAgICAgICA9IDB4MDE7XG5cdE1ldGFFdmVudC5DT1BZUklHSFQgID0gMHgwMjtcblx0TWV0YUV2ZW50LlRSQUNLX05BTUUgPSAweDAzO1xuXHRNZXRhRXZlbnQuSU5TVFJVTUVOVCA9IDB4MDQ7XG5cdE1ldGFFdmVudC5MWVJJQyAgICAgID0gMHgwNTtcblx0TWV0YUV2ZW50Lk1BUktFUiAgICAgPSAweDA2O1xuXHRNZXRhRXZlbnQuQ1VFX1BPSU5UICA9IDB4MDc7XG5cdE1ldGFFdmVudC5DSEFOTkVMX1BSRUZJWCA9IDB4MjA7XG5cdE1ldGFFdmVudC5FTkRfT0ZfVFJBQ0sgICA9IDB4MmY7XG5cdE1ldGFFdmVudC5URU1QTyAgICAgID0gMHg1MTtcblx0TWV0YUV2ZW50LlNNUFRFICAgICAgPSAweDU0O1xuXHRNZXRhRXZlbnQuVElNRV9TSUcgICA9IDB4NTg7XG5cdE1ldGFFdmVudC5LRVlfU0lHICAgID0gMHg1OTtcblx0TWV0YUV2ZW50LlNFUV9FVkVOVCAgPSAweDdmO1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIHRpbWUgZm9yIHRoZSBldmVudCBpbiB0aWNrcyBzaW5jZSB0aGUgcHJldmlvdXMgZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrcyAtIFRoZSBudW1iZXIgb2YgdGlja3Mgc2luY2UgdGhlIHByZXZpb3VzIGV2ZW50LiBNYXlcblx0ICogYmUgemVyby5cblx0ICovXG5cdE1ldGFFdmVudC5wcm90b3R5cGUuc2V0VGltZSA9IGZ1bmN0aW9uKHRpY2tzKSB7XG5cdFx0dGhpcy50aW1lID0gVXRpbC50cmFuc2xhdGVUaWNrVGltZSh0aWNrcyB8fCAwKTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0IHRoZSB0eXBlIG9mIHRoZSBldmVudC4gTXVzdCBiZSBvbmUgb2YgdGhlIGV2ZW50IGNvZGVzIG9uIE1ldGFFdmVudC5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHQgLSBFdmVudCB0eXBlLlxuXHQgKi9cblx0TWV0YUV2ZW50LnByb3RvdHlwZS5zZXRUeXBlID0gZnVuY3Rpb24odCkge1xuXHRcdHRoaXMudHlwZSA9IHQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50LiBNYXkgYmUgYSBzdHJpbmcgb3IgYXJyYXkgb2YgYnl0ZVxuXHQgKiB2YWx1ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBkIC0gRXZlbnQgZGF0YS5cblx0ICovXG5cdE1ldGFFdmVudC5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uKGQpIHtcblx0XHR0aGlzLmRhdGEgPSBkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXJpYWxpemUgdGhlIGV2ZW50IHRvIGFuIGFycmF5IG9mIGJ5dGVzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBvZiBzZXJpYWxpemVkIGJ5dGVzLlxuXHQgKi9cblx0TWV0YUV2ZW50LnByb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLnR5cGUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlR5cGUgZm9yIG1ldGEtZXZlbnQgbm90IHNwZWNpZmllZC5cIik7XG5cdFx0fVxuXG5cdFx0dmFyIGJ5dGVBcnJheSA9IFtdO1xuXHRcdGJ5dGVBcnJheS5wdXNoLmFwcGx5KGJ5dGVBcnJheSwgdGhpcy50aW1lKTtcblx0XHRieXRlQXJyYXkucHVzaCgweEZGLCB0aGlzLnR5cGUpO1xuXG5cdFx0Ly8gSWYgZGF0YSBpcyBhbiBhcnJheSwgd2UgYXNzdW1lIHRoYXQgaXQgY29udGFpbnMgc2V2ZXJhbCBieXRlcy4gV2Vcblx0XHQvLyBhcGVuZCB0aGVtIHRvIGJ5dGVBcnJheS5cblx0XHRpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmRhdGEpKSB7XG5cdFx0XHRieXRlQXJyYXkucHVzaCh0aGlzLmRhdGEubGVuZ3RoKTtcblx0XHRcdGJ5dGVBcnJheS5wdXNoLmFwcGx5KGJ5dGVBcnJheSwgdGhpcy5kYXRhKTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmRhdGEgPT0gJ251bWJlcicpIHtcblx0XHRcdGJ5dGVBcnJheS5wdXNoKDEsIHRoaXMuZGF0YSk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLmRhdGEgIT09IG51bGwgJiYgdGhpcy5kYXRhICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIGFzc3VtZSBzdHJpbmc7IG1heSBiZSBhIGJhZCBhc3N1bXB0aW9uXG5cdFx0XHRieXRlQXJyYXkucHVzaCh0aGlzLmRhdGEubGVuZ3RoKTtcblx0XHRcdHZhciBkYXRhQnl0ZXMgPSB0aGlzLmRhdGEuc3BsaXQoJycpLm1hcChmdW5jdGlvbih4KXsgcmV0dXJuIHguY2hhckNvZGVBdCgwKSB9KTtcblx0XHRcdGJ5dGVBcnJheS5wdXNoLmFwcGx5KGJ5dGVBcnJheSwgZGF0YUJ5dGVzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ynl0ZUFycmF5LnB1c2goMCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJ5dGVBcnJheTtcblx0fTtcblxuXHQvKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ICogVHJhY2sgY2xhc3Ncblx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3QgYSBNSURJIHRyYWNrLlxuXHQgKlxuXHQgKiBQYXJhbWV0ZXJzIGluY2x1ZGU6XG5cdCAqICAtIGV2ZW50cyBbb3B0aW9uYWwgYXJyYXldIC0gQXJyYXkgb2YgZXZlbnRzIGZvciB0aGUgdHJhY2suXG5cdCAqL1xuXHR2YXIgVHJhY2sgPSBmdW5jdGlvbihjb25maWcpIHtcblx0XHRpZiAoIXRoaXMpIHJldHVybiBuZXcgVHJhY2soY29uZmlnKTtcblx0XHR2YXIgYyA9IGNvbmZpZyB8fCB7fTtcblx0XHR0aGlzLmV2ZW50cyA9IGMuZXZlbnRzIHx8IFtdO1xuXHR9O1xuXG5cdFRyYWNrLlNUQVJUX0JZVEVTID0gWzB4NGQsIDB4NTQsIDB4NzIsIDB4NmJdO1xuXHRUcmFjay5FTkRfQllURVMgICA9IFsweDAwLCAweEZGLCAweDJGLCAweDAwXTtcblxuXHQvKipcblx0ICogQWRkIGFuIGV2ZW50IHRvIHRoZSB0cmFjay5cblx0ICpcblx0ICogQHBhcmFtIHtNaWRpRXZlbnR8TWV0YUV2ZW50fSBldmVudCAtIFRoZSBldmVudCB0byBhZGQuXG5cdCAqIEByZXR1cm5zIHtUcmFja30gVGhlIGN1cnJlbnQgdHJhY2suXG5cdCAqL1xuXHRUcmFjay5wcm90b3R5cGUuYWRkRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHRoaXMuZXZlbnRzLnB1c2goZXZlbnQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGQgYSBub3RlLW9uIGV2ZW50IHRvIHRoZSB0cmFjay5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNoYW5uZWwgLSBUaGUgY2hhbm5lbCB0byBhZGQgdGhlIGV2ZW50IHRvLlxuXHQgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHBpdGNoIC0gVGhlIHBpdGNoIG9mIHRoZSBub3RlLCBlaXRoZXIgbnVtZXJpYyBvclxuXHQgKiBzeW1ib2xpYy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTBdIC0gVGhlIG51bWJlciBvZiB0aWNrcyBzaW5jZSB0aGUgcHJldmlvdXMgZXZlbnQsXG5cdCAqIGRlZmF1bHRzIHRvIDAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbdmVsb2NpdHk9OTBdIC0gVGhlIHZvbHVtZSBmb3IgdGhlIG5vdGUsIGRlZmF1bHRzIHRvXG5cdCAqIERFRkFVTFRfVk9MVU1FLlxuXHQgKiBAcmV0dXJucyB7VHJhY2t9IFRoZSBjdXJyZW50IHRyYWNrLlxuXHQgKi9cblx0VHJhY2sucHJvdG90eXBlLmFkZE5vdGVPbiA9IFRyYWNrLnByb3RvdHlwZS5ub3RlT24gPSBmdW5jdGlvbihjaGFubmVsLCBwaXRjaCwgdGltZSwgdmVsb2NpdHkpIHtcblx0XHR0aGlzLmV2ZW50cy5wdXNoKG5ldyBNaWRpRXZlbnQoe1xuXHRcdFx0dHlwZTogTWlkaUV2ZW50Lk5PVEVfT04sXG5cdFx0XHRjaGFubmVsOiBjaGFubmVsLFxuXHRcdFx0cGFyYW0xOiBVdGlsLmVuc3VyZU1pZGlQaXRjaChwaXRjaCksXG5cdFx0XHRwYXJhbTI6IHZlbG9jaXR5IHx8IERFRkFVTFRfVk9MVU1FLFxuXHRcdFx0dGltZTogdGltZSB8fCAwLFxuXHRcdH0pKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWRkIGEgbm90ZS1vZmYgZXZlbnQgdG8gdGhlIHRyYWNrLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gY2hhbm5lbCAtIFRoZSBjaGFubmVsIHRvIGFkZCB0aGUgZXZlbnQgdG8uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gcGl0Y2ggLSBUaGUgcGl0Y2ggb2YgdGhlIG5vdGUsIGVpdGhlciBudW1lcmljIG9yXG5cdCAqIHN5bWJvbGljLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3RpbWU9MF0gLSBUaGUgbnVtYmVyIG9mIHRpY2tzIHNpbmNlIHRoZSBwcmV2aW91cyBldmVudCxcblx0ICogZGVmYXVsdHMgdG8gMC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt2ZWxvY2l0eT05MF0gLSBUaGUgdmVsb2NpdHkgdGhlIG5vdGUgd2FzIHJlbGVhc2VkLFxuXHQgKiBkZWZhdWx0cyB0byBERUZBVUxUX1ZPTFVNRS5cblx0ICogQHJldHVybnMge1RyYWNrfSBUaGUgY3VycmVudCB0cmFjay5cblx0ICovXG5cdFRyYWNrLnByb3RvdHlwZS5hZGROb3RlT2ZmID0gVHJhY2sucHJvdG90eXBlLm5vdGVPZmYgPSBmdW5jdGlvbihjaGFubmVsLCBwaXRjaCwgdGltZSwgdmVsb2NpdHkpIHtcblx0XHR0aGlzLmV2ZW50cy5wdXNoKG5ldyBNaWRpRXZlbnQoe1xuXHRcdFx0dHlwZTogTWlkaUV2ZW50Lk5PVEVfT0ZGLFxuXHRcdFx0Y2hhbm5lbDogY2hhbm5lbCxcblx0XHRcdHBhcmFtMTogVXRpbC5lbnN1cmVNaWRpUGl0Y2gocGl0Y2gpLFxuXHRcdFx0cGFyYW0yOiB2ZWxvY2l0eSB8fCBERUZBVUxUX1ZPTFVNRSxcblx0XHRcdHRpbWU6IHRpbWUgfHwgMCxcblx0XHR9KSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZCBhIG5vdGUtb24gYW5kIC1vZmYgZXZlbnQgdG8gdGhlIHRyYWNrLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gY2hhbm5lbCAtIFRoZSBjaGFubmVsIHRvIGFkZCB0aGUgZXZlbnQgdG8uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gcGl0Y2ggLSBUaGUgcGl0Y2ggb2YgdGhlIG5vdGUsIGVpdGhlciBudW1lcmljIG9yXG5cdCAqIHN5bWJvbGljLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHVyIC0gVGhlIGR1cmF0aW9uIG9mIHRoZSBub3RlLCBpbiB0aWNrcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTBdIC0gVGhlIG51bWJlciBvZiB0aWNrcyBzaW5jZSB0aGUgcHJldmlvdXMgZXZlbnQsXG5cdCAqIGRlZmF1bHRzIHRvIDAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbdmVsb2NpdHk9OTBdIC0gVGhlIHZlbG9jaXR5IHRoZSBub3RlIHdhcyByZWxlYXNlZCxcblx0ICogZGVmYXVsdHMgdG8gREVGQVVMVF9WT0xVTUUuXG5cdCAqIEByZXR1cm5zIHtUcmFja30gVGhlIGN1cnJlbnQgdHJhY2suXG5cdCAqL1xuXHRUcmFjay5wcm90b3R5cGUuYWRkTm90ZSA9IFRyYWNrLnByb3RvdHlwZS5ub3RlID0gZnVuY3Rpb24oY2hhbm5lbCwgcGl0Y2gsIGR1ciwgdGltZSwgdmVsb2NpdHkpIHtcblx0XHR0aGlzLm5vdGVPbihjaGFubmVsLCBwaXRjaCwgdGltZSwgdmVsb2NpdHkpO1xuXHRcdGlmIChkdXIpIHtcblx0XHRcdHRoaXMubm90ZU9mZihjaGFubmVsLCBwaXRjaCwgZHVyLCB2ZWxvY2l0eSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGQgYSBub3RlLW9uIGFuZCAtb2ZmIGV2ZW50IHRvIHRoZSB0cmFjayBmb3IgZWFjaCBwaXRjaCBpbiBhbiBhcnJheSBvZiBwaXRjaGVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gY2hhbm5lbCAtIFRoZSBjaGFubmVsIHRvIGFkZCB0aGUgZXZlbnQgdG8uXG5cdCAqIEBwYXJhbSB7YXJyYXl9IGNob3JkIC0gQW4gYXJyYXkgb2YgcGl0Y2hlcywgZWl0aGVyIG51bWVyaWMgb3Jcblx0ICogc3ltYm9saWMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXIgLSBUaGUgZHVyYXRpb24gb2YgdGhlIGNob3JkLCBpbiB0aWNrcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt2ZWxvY2l0eT05MF0gLSBUaGUgdmVsb2NpdHkgb2YgdGhlIGNob3JkLFxuXHQgKiBkZWZhdWx0cyB0byBERUZBVUxUX1ZPTFVNRS5cblx0ICogQHJldHVybnMge1RyYWNrfSBUaGUgY3VycmVudCB0cmFjay5cblx0ICovXG5cdFRyYWNrLnByb3RvdHlwZS5hZGRDaG9yZCA9IFRyYWNrLnByb3RvdHlwZS5jaG9yZCA9IGZ1bmN0aW9uKGNoYW5uZWwsIGNob3JkLCBkdXIsIHZlbG9jaXR5KSB7XG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGNob3JkKSAmJiAhY2hvcmQubGVuZ3RoKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Nob3JkIG11c3QgYmUgYW4gYXJyYXkgb2YgcGl0Y2hlcycpO1xuXHRcdH1cblx0XHRjaG9yZC5mb3JFYWNoKGZ1bmN0aW9uKG5vdGUpIHtcblx0XHRcdHRoaXMubm90ZU9uKGNoYW5uZWwsIG5vdGUsIDAsIHZlbG9jaXR5KTtcblx0XHR9LCB0aGlzKTtcblx0XHRjaG9yZC5mb3JFYWNoKGZ1bmN0aW9uKG5vdGUsIGluZGV4KSB7XG5cdFx0XHRpZiAoaW5kZXggPT09IDApIHtcblx0XHRcdFx0dGhpcy5ub3RlT2ZmKGNoYW5uZWwsIG5vdGUsIGR1cik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm5vdGVPZmYoY2hhbm5lbCwgbm90ZSk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldCBpbnN0cnVtZW50IGZvciB0aGUgdHJhY2suXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjaGFubmVsIC0gVGhlIGNoYW5uZWwgdG8gc2V0IHRoZSBpbnN0cnVtZW50IG9uLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5zdHJ1bWVudCAtIFRoZSBpbnN0cnVtZW50IHRvIHNldCBpdCB0by5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTBdIC0gVGhlIG51bWJlciBvZiB0aWNrcyBzaW5jZSB0aGUgcHJldmlvdXMgZXZlbnQsXG5cdCAqIGRlZmF1bHRzIHRvIDAuXG5cdCAqIEByZXR1cm5zIHtUcmFja30gVGhlIGN1cnJlbnQgdHJhY2suXG5cdCAqL1xuXHRUcmFjay5wcm90b3R5cGUuc2V0SW5zdHJ1bWVudCA9IFRyYWNrLnByb3RvdHlwZS5pbnN0cnVtZW50ID0gZnVuY3Rpb24oY2hhbm5lbCwgaW5zdHJ1bWVudCwgdGltZSkge1xuXHRcdHRoaXMuZXZlbnRzLnB1c2gobmV3IE1pZGlFdmVudCh7XG5cdFx0XHR0eXBlOiBNaWRpRXZlbnQuUFJPR1JBTV9DSEFOR0UsXG5cdFx0XHRjaGFubmVsOiBjaGFubmVsLFxuXHRcdFx0cGFyYW0xOiBpbnN0cnVtZW50LFxuXHRcdFx0dGltZTogdGltZSB8fCAwLFxuXHRcdH0pKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU2V0IHRoZSB0ZW1wbyBmb3IgdGhlIHRyYWNrLlxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gYnBtIC0gVGhlIG5ldyBudW1iZXIgb2YgYmVhdHMgcGVyIG1pbnV0ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTBdIC0gVGhlIG51bWJlciBvZiB0aWNrcyBzaW5jZSB0aGUgcHJldmlvdXMgZXZlbnQsXG5cdCAqIGRlZmF1bHRzIHRvIDAuXG5cdCAqIEByZXR1cm5zIHtUcmFja30gVGhlIGN1cnJlbnQgdHJhY2suXG5cdCAqL1xuXHRUcmFjay5wcm90b3R5cGUuc2V0VGVtcG8gPSBUcmFjay5wcm90b3R5cGUudGVtcG8gPSBmdW5jdGlvbihicG0sIHRpbWUpIHtcblx0XHR0aGlzLmV2ZW50cy5wdXNoKG5ldyBNZXRhRXZlbnQoe1xuXHRcdFx0dHlwZTogTWV0YUV2ZW50LlRFTVBPLFxuXHRcdFx0ZGF0YTogVXRpbC5tcHFuRnJvbUJwbShicG0pLFxuXHRcdFx0dGltZTogdGltZSB8fCAwLFxuXHRcdH0pKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU2VyaWFsaXplIHRoZSB0cmFjayB0byBhbiBhcnJheSBvZiBieXRlcy5cblx0ICpcblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2Ygc2VyaWFsaXplZCBieXRlcy5cblx0ICovXG5cdFRyYWNrLnByb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRyYWNrTGVuZ3RoID0gMDtcblx0XHR2YXIgZXZlbnRCeXRlcyA9IFtdO1xuXHRcdHZhciBzdGFydEJ5dGVzID0gVHJhY2suU1RBUlRfQllURVM7XG5cdFx0dmFyIGVuZEJ5dGVzICAgPSBUcmFjay5FTkRfQllURVM7XG5cblx0XHR2YXIgYWRkRXZlbnRCeXRlcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgYnl0ZXMgPSBldmVudC50b0J5dGVzKCk7XG5cdFx0XHR0cmFja0xlbmd0aCArPSBieXRlcy5sZW5ndGg7XG5cdFx0XHRldmVudEJ5dGVzLnB1c2guYXBwbHkoZXZlbnRCeXRlcywgYnl0ZXMpO1xuXHRcdH07XG5cblx0XHR0aGlzLmV2ZW50cy5mb3JFYWNoKGFkZEV2ZW50Qnl0ZXMpO1xuXG5cdFx0Ly8gQWRkIHRoZSBlbmQtb2YtdHJhY2sgYnl0ZXMgdG8gdGhlIHN1bSBvZiBieXRlcyBmb3IgdGhlIHRyYWNrLCBzaW5jZVxuXHRcdC8vIHRoZXkgYXJlIGNvdW50ZWQgKHVubGlrZSB0aGUgc3RhcnQtb2YtdHJhY2sgb25lcykuXG5cdFx0dHJhY2tMZW5ndGggKz0gZW5kQnl0ZXMubGVuZ3RoO1xuXG5cdFx0Ly8gTWFrZXMgc3VyZSB0aGF0IHRyYWNrIGxlbmd0aCB3aWxsIGZpbGwgdXAgNCBieXRlcyB3aXRoIDBzIGluIGNhc2Vcblx0XHQvLyB0aGUgbGVuZ3RoIGlzIGxlc3MgdGhhbiB0aGF0ICh0aGUgdXN1YWwgY2FzZSkuXG5cdFx0dmFyIGxlbmd0aEJ5dGVzID0gVXRpbC5zdHIyQnl0ZXModHJhY2tMZW5ndGgudG9TdHJpbmcoMTYpLCA0KTtcblxuXHRcdHJldHVybiBzdGFydEJ5dGVzLmNvbmNhdChsZW5ndGhCeXRlcywgZXZlbnRCeXRlcywgZW5kQnl0ZXMpO1xuXHR9O1xuXG5cdC8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgKiBGaWxlIGNsYXNzXG5cdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuXHQvKipcblx0ICogQ29uc3RydWN0IGEgZmlsZSBvYmplY3QuXG5cdCAqXG5cdCAqIFBhcmFtZXRlcnMgaW5jbHVkZTpcblx0ICogIC0gdGlja3MgW29wdGlvbmFsIG51bWJlcl0gLSBOdW1iZXIgb2YgdGlja3MgcGVyIGJlYXQsIGRlZmF1bHRzIHRvIDEyOC5cblx0ICogICAgTXVzdCBiZSAxLTMyNzY3LlxuXHQgKiAgLSB0cmFja3MgW29wdGlvbmFsIGFycmF5XSAtIFRyYWNrIGRhdGEuXG5cdCAqL1xuXHR2YXIgRmlsZSA9IGZ1bmN0aW9uKGNvbmZpZyl7XG5cdFx0aWYgKCF0aGlzKSByZXR1cm4gbmV3IEZpbGUoY29uZmlnKTtcblxuXHRcdHZhciBjID0gY29uZmlnIHx8IHt9O1xuXHRcdGlmIChjLnRpY2tzKSB7XG5cdFx0XHRpZiAodHlwZW9mIGMudGlja3MgIT09ICdudW1iZXInKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVGlja3MgcGVyIGJlYXQgbXVzdCBiZSBhIG51bWJlciEnKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGMudGlja3MgPD0gMCB8fCBjLnRpY2tzID49ICgxIDw8IDE1KSB8fCBjLnRpY2tzICUgMSAhPT0gMCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RpY2tzIHBlciBiZWF0IG11c3QgYmUgYW4gaW50ZWdlciBiZXR3ZWVuIDEgYW5kIDMyNzY3IScpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy50aWNrcyA9IGMudGlja3MgfHwgMTI4O1xuXHRcdHRoaXMudHJhY2tzID0gYy50cmFja3MgfHwgW107XG5cdH07XG5cblx0RmlsZS5IRFJfQ0hVTktJRCAgICAgPSBcIk1UaGRcIjsgICAgICAgICAgICAgLy8gRmlsZSBtYWdpYyBjb29raWVcblx0RmlsZS5IRFJfQ0hVTktfU0laRSAgPSBcIlxceDAwXFx4MDBcXHgwMFxceDA2XCI7IC8vIEhlYWRlciBsZW5ndGggZm9yIFNNRlxuXHRGaWxlLkhEUl9UWVBFMCAgICAgICA9IFwiXFx4MDBcXHgwMFwiOyAgICAgICAgIC8vIE1pZGkgVHlwZSAwIGlkXG5cdEZpbGUuSERSX1RZUEUxICAgICAgID0gXCJcXHgwMFxceDAxXCI7ICAgICAgICAgLy8gTWlkaSBUeXBlIDEgaWRcblxuXHQvKipcblx0ICogQWRkIGEgdHJhY2sgdG8gdGhlIGZpbGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VHJhY2t9IHRyYWNrIC0gVGhlIHRyYWNrIHRvIGFkZC5cblx0ICovXG5cdEZpbGUucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24odHJhY2spIHtcblx0XHRpZiAodHJhY2spIHtcblx0XHRcdHRoaXMudHJhY2tzLnB1c2godHJhY2spO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRyYWNrID0gbmV3IFRyYWNrKCk7XG5cdFx0XHR0aGlzLnRyYWNrcy5wdXNoKHRyYWNrKTtcblx0XHRcdHJldHVybiB0cmFjaztcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFNlcmlhbGl6ZSB0aGUgTUlESSBmaWxlIHRvIGFuIGFycmF5IG9mIGJ5dGVzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBvZiBzZXJpYWxpemVkIGJ5dGVzLlxuXHQgKi9cblx0RmlsZS5wcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0cmFja0NvdW50ID0gdGhpcy50cmFja3MubGVuZ3RoLnRvU3RyaW5nKDE2KTtcblxuXHRcdC8vIHByZXBhcmUgdGhlIGZpbGUgaGVhZGVyXG5cdFx0dmFyIGJ5dGVzID0gRmlsZS5IRFJfQ0hVTktJRCArIEZpbGUuSERSX0NIVU5LX1NJWkU7XG5cblx0XHQvLyBzZXQgTWlkaSB0eXBlIGJhc2VkIG9uIG51bWJlciBvZiB0cmFja3Ncblx0XHRpZiAocGFyc2VJbnQodHJhY2tDb3VudCwgMTYpID4gMSkge1xuXHRcdFx0Ynl0ZXMgKz0gRmlsZS5IRFJfVFlQRTE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGJ5dGVzICs9IEZpbGUuSERSX1RZUEUwO1xuXHRcdH1cblxuXHRcdC8vIGFkZCB0aGUgbnVtYmVyIG9mIHRyYWNrcyAoMiBieXRlcylcblx0XHRieXRlcyArPSBVdGlsLmNvZGVzMlN0cihVdGlsLnN0cjJCeXRlcyh0cmFja0NvdW50LCAyKSk7XG5cdFx0Ly8gYWRkIHRoZSBudW1iZXIgb2YgdGlja3MgcGVyIGJlYXQgKGN1cnJlbnRseSBoYXJkY29kZWQpXG5cdFx0Ynl0ZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgodGhpcy50aWNrcy8yNTYpLCAgdGhpcy50aWNrcyUyNTYpOztcblxuXHRcdC8vIGl0ZXJhdGUgb3ZlciB0aGUgdHJhY2tzLCBjb252ZXJ0aW5nIHRvIGJ5dGVzIHRvb1xuXHRcdHRoaXMudHJhY2tzLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHtcblx0XHRcdGJ5dGVzICs9IFV0aWwuY29kZXMyU3RyKHRyYWNrLnRvQnl0ZXMoKSk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gYnl0ZXM7XG5cdH07XG5cblx0LyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAqIEV4cG9ydHNcblx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5cdGV4cG9ydGVkLlV0aWwgPSBVdGlsO1xuXHRleHBvcnRlZC5GaWxlID0gRmlsZTtcblx0ZXhwb3J0ZWQuVHJhY2sgPSBUcmFjaztcblx0ZXhwb3J0ZWQuRXZlbnQgPSBNaWRpRXZlbnQ7XG5cdGV4cG9ydGVkLk1ldGFFdmVudCA9IE1ldGFFdmVudDtcblxufSkoIE1pZGkgKTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlICE9PSBudWxsKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gTWlkaTtcbn0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgZXhwb3J0cyAhPT0gbnVsbCkge1xuXHRleHBvcnRzID0gTWlkaTtcbn0gZWxzZSB7XG5cdHRoaXMuTWlkaSA9IE1pZGk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vanNtaWRnZW4vbGliL2pzbWlkZ2VuLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 4 */
/***/ function(module, exports) {

	eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2MzYzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 5 */
/***/ function(module, exports) {

	eval("'use strict';\n\nfunction cleanName(str) {\n\t//ableton adds some weird stuff to the track\n\treturn str.replace(/\\u0000/g, '');\n}\n\nfunction ticksToSeconds(ticks, header) {\n\treturn 60 / header.bpm * (ticks / header.PPQ);\n}\n\nfunction isNumber(val) {\n\treturn typeof val === 'number';\n}\n\nfunction isString(val) {\n\treturn typeof val === 'string';\n}\n\nvar isPitch = function () {\n\tvar regexp = /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i;\n\treturn function (val) {\n\t\treturn isString(val) && regexp.test(val);\n\t};\n}();\n\nfunction midiToPitch(midi) {\n\tvar scaleIndexToNote = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n\tvar octave = Math.floor(midi / 12) - 1;\n\tvar note = midi % 12;\n\treturn scaleIndexToNote[note] + octave;\n}\n\nvar pitchToMidi = function () {\n\tvar regexp = /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i;\n\tvar noteToScaleIndex = {\n\t\t\"cbb\": -2, \"cb\": -1, \"c\": 0, \"c#\": 1, \"cx\": 2,\n\t\t\"dbb\": 0, \"db\": 1, \"d\": 2, \"d#\": 3, \"dx\": 4,\n\t\t\"ebb\": 2, \"eb\": 3, \"e\": 4, \"e#\": 5, \"ex\": 6,\n\t\t\"fbb\": 3, \"fb\": 4, \"f\": 5, \"f#\": 6, \"fx\": 7,\n\t\t\"gbb\": 5, \"gb\": 6, \"g\": 7, \"g#\": 8, \"gx\": 9,\n\t\t\"abb\": 7, \"ab\": 8, \"a\": 9, \"a#\": 10, \"ax\": 11,\n\t\t\"bbb\": 9, \"bb\": 10, \"b\": 11, \"b#\": 12, \"bx\": 13\n\t};\n\treturn function (note) {\n\t\tvar split = regexp.exec(note);\n\t\tvar pitch = split[1];\n\t\tvar octave = split[2];\n\t\tvar index = noteToScaleIndex[pitch.toLowerCase()];\n\t\treturn index + (parseInt(octave) + 1) * 12;\n\t};\n}();\n\nmodule.exports = { cleanName: cleanName, ticksToSeconds: ticksToSeconds, isString: isString, isNumber: isNumber, isPitch: isPitch, midiToPitch: midiToPitch, pitchToMidi: pitchToMidi };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvVXRpbC5qcz9iYmQ5Il0sIm5hbWVzIjpbImNsZWFuTmFtZSIsInN0ciIsInJlcGxhY2UiLCJ0aWNrc1RvU2Vjb25kcyIsInRpY2tzIiwiaGVhZGVyIiwiYnBtIiwiUFBRIiwiaXNOdW1iZXIiLCJ2YWwiLCJpc1N0cmluZyIsImlzUGl0Y2giLCJyZWdleHAiLCJ0ZXN0IiwibWlkaVRvUGl0Y2giLCJtaWRpIiwic2NhbGVJbmRleFRvTm90ZSIsIm9jdGF2ZSIsIk1hdGgiLCJmbG9vciIsIm5vdGUiLCJwaXRjaFRvTWlkaSIsIm5vdGVUb1NjYWxlSW5kZXgiLCJzcGxpdCIsImV4ZWMiLCJwaXRjaCIsImluZGV4IiwidG9Mb3dlckNhc2UiLCJwYXJzZUludCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7O0FBQUEsU0FBU0EsU0FBVCxDQUFtQkMsR0FBbkIsRUFBdUI7QUFDdEI7QUFDQSxRQUFPQSxJQUFJQyxPQUFKLENBQVksU0FBWixFQUF1QixFQUF2QixDQUFQO0FBQ0E7O0FBRUQsU0FBU0MsY0FBVCxDQUF3QkMsS0FBeEIsRUFBK0JDLE1BQS9CLEVBQXNDO0FBQ3JDLFFBQVEsS0FBS0EsT0FBT0MsR0FBYixJQUFxQkYsUUFBUUMsT0FBT0UsR0FBcEMsQ0FBUDtBQUNBOztBQUVELFNBQVNDLFFBQVQsQ0FBa0JDLEdBQWxCLEVBQXNCO0FBQ3JCLFFBQU8sT0FBT0EsR0FBUCxLQUFlLFFBQXRCO0FBQ0E7O0FBRUQsU0FBU0MsUUFBVCxDQUFrQkQsR0FBbEIsRUFBc0I7QUFDckIsUUFBTyxPQUFPQSxHQUFQLEtBQWUsUUFBdEI7QUFDQTs7QUFFRCxJQUFNRSxVQUFXLFlBQVU7QUFDMUIsS0FBTUMsU0FBUyxxQ0FBZjtBQUNBLFFBQU8sVUFBQ0gsR0FBRCxFQUFTO0FBQ2YsU0FBT0MsU0FBU0QsR0FBVCxLQUFpQkcsT0FBT0MsSUFBUCxDQUFZSixHQUFaLENBQXhCO0FBQ0EsRUFGRDtBQUdBLENBTGdCLEVBQWpCOztBQVFBLFNBQVNLLFdBQVQsQ0FBcUJDLElBQXJCLEVBQTBCO0FBQ3pCLEtBQU1DLG1CQUFtQixDQUFDLEdBQUQsRUFBTSxJQUFOLEVBQVksR0FBWixFQUFpQixJQUFqQixFQUF1QixHQUF2QixFQUE0QixHQUE1QixFQUFpQyxJQUFqQyxFQUF1QyxHQUF2QyxFQUE0QyxJQUE1QyxFQUFrRCxHQUFsRCxFQUF1RCxJQUF2RCxFQUE2RCxHQUE3RCxDQUF6QjtBQUNBLEtBQU1DLFNBQVNDLEtBQUtDLEtBQUwsQ0FBV0osT0FBTyxFQUFsQixJQUF3QixDQUF2QztBQUNBLEtBQU1LLE9BQU9MLE9BQU8sRUFBcEI7QUFDQSxRQUFPQyxpQkFBaUJJLElBQWpCLElBQXlCSCxNQUFoQztBQUNBOztBQUVELElBQU1JLGNBQWUsWUFBVTtBQUM5QixLQUFNVCxTQUFTLHFDQUFmO0FBQ0EsS0FBTVUsbUJBQW1CO0FBQ3hCLFNBQVEsQ0FBQyxDQURlLEVBQ1osTUFBTyxDQUFDLENBREksRUFDRCxLQUFNLENBREwsRUFDUyxNQUFPLENBRGhCLEVBQ29CLE1BQU8sQ0FEM0I7QUFFeEIsU0FBUSxDQUZnQixFQUVaLE1BQU8sQ0FGSyxFQUVELEtBQU0sQ0FGTCxFQUVTLE1BQU8sQ0FGaEIsRUFFb0IsTUFBTyxDQUYzQjtBQUd4QixTQUFRLENBSGdCLEVBR1osTUFBTyxDQUhLLEVBR0QsS0FBTSxDQUhMLEVBR1MsTUFBTyxDQUhoQixFQUdvQixNQUFPLENBSDNCO0FBSXhCLFNBQVEsQ0FKZ0IsRUFJWixNQUFPLENBSkssRUFJRCxLQUFNLENBSkwsRUFJUyxNQUFPLENBSmhCLEVBSW9CLE1BQU8sQ0FKM0I7QUFLeEIsU0FBUSxDQUxnQixFQUtaLE1BQU8sQ0FMSyxFQUtELEtBQU0sQ0FMTCxFQUtTLE1BQU8sQ0FMaEIsRUFLb0IsTUFBTyxDQUwzQjtBQU14QixTQUFRLENBTmdCLEVBTVosTUFBTyxDQU5LLEVBTUQsS0FBTSxDQU5MLEVBTVMsTUFBTyxFQU5oQixFQU1vQixNQUFPLEVBTjNCO0FBT3hCLFNBQVEsQ0FQZ0IsRUFPWixNQUFPLEVBUEssRUFPRCxLQUFNLEVBUEwsRUFPUyxNQUFPLEVBUGhCLEVBT29CLE1BQU87QUFQM0IsRUFBekI7QUFTQSxRQUFPLFVBQUNGLElBQUQsRUFBVTtBQUNoQixNQUFNRyxRQUFRWCxPQUFPWSxJQUFQLENBQVlKLElBQVosQ0FBZDtBQUNBLE1BQU1LLFFBQVFGLE1BQU0sQ0FBTixDQUFkO0FBQ0EsTUFBTU4sU0FBU00sTUFBTSxDQUFOLENBQWY7QUFDQSxNQUFNRyxRQUFRSixpQkFBaUJHLE1BQU1FLFdBQU4sRUFBakIsQ0FBZDtBQUNBLFNBQU9ELFFBQVEsQ0FBQ0UsU0FBU1gsTUFBVCxJQUFtQixDQUFwQixJQUF5QixFQUF4QztBQUNBLEVBTkQ7QUFPQSxDQWxCb0IsRUFBckI7O0FBb0JBWSxPQUFPQyxPQUFQLEdBQWlCLEVBQUM5QixvQkFBRCxFQUFZRyw4QkFBWixFQUE0Qk8sa0JBQTVCLEVBQXNDRixrQkFBdEMsRUFBZ0RHLGdCQUFoRCxFQUF5REcsd0JBQXpELEVBQXNFTyx3QkFBdEUsRUFBakIiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGNsZWFuTmFtZShzdHIpe1xuXHQvL2FibGV0b24gYWRkcyBzb21lIHdlaXJkIHN0dWZmIHRvIHRoZSB0cmFja1xuXHRyZXR1cm4gc3RyLnJlcGxhY2UoL1xcdTAwMDAvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRpY2tzVG9TZWNvbmRzKHRpY2tzLCBoZWFkZXIpe1xuXHRyZXR1cm4gKDYwIC8gaGVhZGVyLmJwbSkgKiAodGlja3MgLyBoZWFkZXIuUFBRKTtcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIodmFsKXtcblx0cmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCl7XG5cdHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJ1xufVxuXG5jb25zdCBpc1BpdGNoID0gKGZ1bmN0aW9uKCl7XG5cdGNvbnN0IHJlZ2V4cCA9IC9eKFthLWddezF9KD86YnwjfHh8YmIpPykoLT9bMC05XSspL2lcblx0cmV0dXJuICh2YWwpID0+IHtcblx0XHRyZXR1cm4gaXNTdHJpbmcodmFsKSAmJiByZWdleHAudGVzdCh2YWwpXG5cdH1cbn0oKSlcblxuXG5mdW5jdGlvbiBtaWRpVG9QaXRjaChtaWRpKXtcblx0Y29uc3Qgc2NhbGVJbmRleFRvTm90ZSA9IFtcIkNcIiwgXCJDI1wiLCBcIkRcIiwgXCJEI1wiLCBcIkVcIiwgXCJGXCIsIFwiRiNcIiwgXCJHXCIsIFwiRyNcIiwgXCJBXCIsIFwiQSNcIiwgXCJCXCJdO1xuXHRjb25zdCBvY3RhdmUgPSBNYXRoLmZsb29yKG1pZGkgLyAxMikgLSAxO1xuXHRjb25zdCBub3RlID0gbWlkaSAlIDEyO1xuXHRyZXR1cm4gc2NhbGVJbmRleFRvTm90ZVtub3RlXSArIG9jdGF2ZTtcbn1cblxuY29uc3QgcGl0Y2hUb01pZGkgPSAoZnVuY3Rpb24oKXtcblx0Y29uc3QgcmVnZXhwID0gL14oW2EtZ117MX0oPzpifCN8eHxiYik/KSgtP1swLTldKykvaVxuXHRjb25zdCBub3RlVG9TY2FsZUluZGV4ID0ge1xuXHRcdFwiY2JiXCIgOiAtMiwgXCJjYlwiIDogLTEsIFwiY1wiIDogMCwgIFwiYyNcIiA6IDEsICBcImN4XCIgOiAyLCBcblx0XHRcImRiYlwiIDogMCwgIFwiZGJcIiA6IDEsICBcImRcIiA6IDIsICBcImQjXCIgOiAzLCAgXCJkeFwiIDogNCxcblx0XHRcImViYlwiIDogMiwgIFwiZWJcIiA6IDMsICBcImVcIiA6IDQsICBcImUjXCIgOiA1LCAgXCJleFwiIDogNiwgXG5cdFx0XCJmYmJcIiA6IDMsICBcImZiXCIgOiA0LCAgXCJmXCIgOiA1LCAgXCJmI1wiIDogNiwgIFwiZnhcIiA6IDcsXG5cdFx0XCJnYmJcIiA6IDUsICBcImdiXCIgOiA2LCAgXCJnXCIgOiA3LCAgXCJnI1wiIDogOCwgIFwiZ3hcIiA6IDksXG5cdFx0XCJhYmJcIiA6IDcsICBcImFiXCIgOiA4LCAgXCJhXCIgOiA5LCAgXCJhI1wiIDogMTAsIFwiYXhcIiA6IDExLFxuXHRcdFwiYmJiXCIgOiA5LCAgXCJiYlwiIDogMTAsIFwiYlwiIDogMTEsIFwiYiNcIiA6IDEyLCBcImJ4XCIgOiAxMyxcblx0fVxuXHRyZXR1cm4gKG5vdGUpID0+IHtcblx0XHRjb25zdCBzcGxpdCA9IHJlZ2V4cC5leGVjKG5vdGUpXG5cdFx0Y29uc3QgcGl0Y2ggPSBzcGxpdFsxXVxuXHRcdGNvbnN0IG9jdGF2ZSA9IHNwbGl0WzJdXG5cdFx0Y29uc3QgaW5kZXggPSBub3RlVG9TY2FsZUluZGV4W3BpdGNoLnRvTG93ZXJDYXNlKCldXG5cdFx0cmV0dXJuIGluZGV4ICsgKHBhcnNlSW50KG9jdGF2ZSkgKyAxKSAqIDEyXG5cdH1cbn0oKSlcblxubW9kdWxlLmV4cG9ydHMgPSB7Y2xlYW5OYW1lLCB0aWNrc1RvU2Vjb25kcywgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc1BpdGNoLCBtaWRpVG9QaXRjaCwgcGl0Y2hUb01pZGl9XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1V0aWwuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.Track = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Note = __webpack_require__(7);\n\nvar _Control = __webpack_require__(8);\n\nvar _Merge = __webpack_require__(9);\n\nvar _BinaryInsert = __webpack_require__(10);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Track = function () {\n\tfunction Track() {\n\t\tvar name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\t\tvar instrument = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n\t\t_classCallCheck(this, Track);\n\n\t\t/**\n   * The name of the track\n   * @type {String}\n   */\n\t\tthis.name = name;\n\n\t\t/**\n   * The note events\n   * @type {Array}\n   */\n\t\tthis.notes = [];\n\n\t\t/**\n   * The control changes\n   * @type {Object}\n   */\n\t\tthis.controlChanges = {};\n\n\t\t/**\n   * The tracks insturment if one exists\n   * @type {String}\n   */\n\t\tthis.instrument = '';\n\t}\n\n\t_createClass(Track, [{\n\t\tkey: 'note',\n\t\tvalue: function note(midi, time) {\n\t\t\tvar duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\t\t\tvar velocity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n\t\t\tvar note = new _Note.Note(midi, time, duration, velocity);\n\t\t\t(0, _BinaryInsert.BinaryInsert)(this.notes, note);\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n   * Add a note on event\n   * @param  {Number|String} midi     The midi note as either a midi number or \n   *                                  Pitch Notation like ('C#4')\n   * @param  {Number} time     The time in seconds\n   * @param  {Number} velocity The velocity value 0-1\n   * @return {Track} this\n   */\n\n\t}, {\n\t\tkey: 'noteOn',\n\t\tvalue: function noteOn(midi, time) {\n\t\t\tvar velocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n\t\t\tvar note = new _Note.Note(midi, time, 0, velocity);\n\t\t\t(0, _BinaryInsert.BinaryInsert)(this.notes, note);\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n   * Add a note off event. Go through and find an unresolved\n   * noteOn event with the same pitch.\n   * @param  {String|Number} midi The midi number or note name.\n   * @param  {Number} time The time of the event in seconds\n   * @return {Track} this\n   */\n\n\t}, {\n\t\tkey: 'noteOff',\n\t\tvalue: function noteOff(midi, time) {\n\t\t\tfor (var i = 0; i < this.notes.length; i++) {\n\t\t\t\tvar note = this.notes[i];\n\t\t\t\tif (note.match(midi) && note.duration === 0) {\n\t\t\t\t\tnote.noteOff = time;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n   * Add a CC event\n   * @param  {Number} num The CC number\n   * @param  {Number} time The time of the event in seconds\n   * @param {Number} value The value of the CC\n   * @return {Track} this\n   */\n\n\t}, {\n\t\tkey: 'cc',\n\t\tvalue: function cc(num, time, value) {\n\t\t\tif (!this.controlChanges.hasOwnProperty(num)) {\n\t\t\t\tthis.controlChanges[num] = [];\n\t\t\t}\n\t\t\tvar cc = new _Control.Control(num, time, value);\n\t\t\t(0, _BinaryInsert.BinaryInsert)(this.controlChanges[num], cc);\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n   * An array of all the note on events\n   * @type {Array<Object>}\n   * @readOnly\n   */\n\n\t}, {\n\t\tkey: 'scale',\n\n\n\t\t/**\n   * Scale the timing of all the events in the track\n   * @param {Number} amount The amount to scale all the values\n   */\n\t\tvalue: function scale(amount) {\n\t\t\tthis.notes.forEach(function (note) {\n\t\t\t\tnote.time *= amount;\n\t\t\t\tnote.duration *= amount;\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n   * Slice returns a new track with only events that occured between startTime and endTime. \n   * Modifies this track.\n   * @param {Number} startTime\n   * @param {Number} endTime\n   * @returns {Track}\n   */\n\n\t}, {\n\t\tkey: 'slice',\n\t\tvalue: function slice() {\n\t\t\tvar startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t\t\tvar endTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.duration;\n\n\t\t\t// get the index before the startTime\n\t\t\tvar noteStartIndex = Math.max(this.notes.findIndex(function (note) {\n\t\t\t\treturn note.time >= startTime;\n\t\t\t}), 0);\n\t\t\tvar noteEndIndex = this.notes.findIndex(function (note) {\n\t\t\t\treturn note.noteOff >= endTime;\n\t\t\t}) + 1;\n\t\t\tvar track = new Track(this.name);\n\t\t\ttrack.notes = this.notes.slice(noteStartIndex, noteEndIndex);\n\t\t\t//shift the start time\n\t\t\ttrack.notes.forEach(function (note) {\n\t\t\t\treturn note.time = note.time - startTime;\n\t\t\t});\n\t\t\treturn track;\n\t\t}\n\n\t\t/**\n   * Write the output to the stream\n   */\n\n\t}, {\n\t\tkey: 'encode',\n\t\tvalue: function encode(trackEncoder, header) {\n\n\t\t\tvar ticksPerSecond = header.PPQ / (60 / header.bpm);\n\t\t\tvar lastEventTime = 0;\n\n\t\t\tvar CHANNEL = 0;\n\n\t\t\tfunction getDeltaTime(time) {\n\t\t\t\tvar ticks = Math.floor(ticksPerSecond * time);\n\t\t\t\tvar delta = Math.max(ticks - lastEventTime, 0);\n\t\t\t\tlastEventTime = ticks;\n\t\t\t\treturn delta;\n\t\t\t}\n\n\t\t\t(0, _Merge.Merge)(this.noteOns, function (noteOn) {\n\t\t\t\ttrackEncoder.addNoteOn(CHANNEL, noteOn.name, getDeltaTime(noteOn.time), Math.floor(noteOn.velocity * 127));\n\t\t\t}, this.noteOffs, function (noteOff) {\n\t\t\t\ttrackEncoder.addNoteOff(CHANNEL, noteOff.name, getDeltaTime(noteOff.time));\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: 'noteOns',\n\t\tget: function get() {\n\t\t\tvar noteOns = [];\n\t\t\tthis.notes.forEach(function (note) {\n\t\t\t\tnoteOns.push({\n\t\t\t\t\ttime: note.noteOn,\n\t\t\t\t\tmidi: note.midi,\n\t\t\t\t\tname: note.name,\n\t\t\t\t\tvelocity: note.velocity\n\t\t\t\t});\n\t\t\t});\n\t\t\treturn noteOns;\n\t\t}\n\n\t\t/**\n   * An array of all the noteOff events\n   * @type {Array<Object>}\n   * @readOnly\n   */\n\n\t}, {\n\t\tkey: 'noteOffs',\n\t\tget: function get() {\n\t\t\tvar noteOffs = [];\n\t\t\tthis.notes.forEach(function (note) {\n\t\t\t\tnoteOffs.push({\n\t\t\t\t\ttime: note.noteOff,\n\t\t\t\t\tmidi: note.midi,\n\t\t\t\t\tname: note.name\n\t\t\t\t});\n\t\t\t});\n\t\t\treturn noteOffs;\n\t\t}\n\n\t\t/**\n   * The length in seconds of the track\n   * @type {Number}\n   */\n\n\t}, {\n\t\tkey: 'length',\n\t\tget: function get() {\n\t\t\treturn this.notes.length;\n\t\t}\n\n\t\t/**\n   * The time of the first event in seconds\n   * @type {Number}\n   */\n\n\t}, {\n\t\tkey: 'startTime',\n\t\tget: function get() {\n\t\t\tif (this.notes.length) {\n\t\t\t\tvar firstNote = this.notes[0];\n\t\t\t\treturn firstNote.noteOn;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * The time of the last event in seconds\n   * @type {Number}\n   */\n\n\t}, {\n\t\tkey: 'duration',\n\t\tget: function get() {\n\t\t\tif (this.notes.length) {\n\t\t\t\tvar lastNote = this.notes[this.notes.length - 1];\n\t\t\t\treturn lastNote.noteOff;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn Track;\n}();\n\nexports.Track = Track;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvVHJhY2suanM/YjIzOCJdLCJuYW1lcyI6WyJUcmFjayIsIm5hbWUiLCJpbnN0cnVtZW50Iiwibm90ZXMiLCJjb250cm9sQ2hhbmdlcyIsIm1pZGkiLCJ0aW1lIiwiZHVyYXRpb24iLCJ2ZWxvY2l0eSIsIm5vdGUiLCJpIiwibGVuZ3RoIiwibWF0Y2giLCJub3RlT2ZmIiwibnVtIiwidmFsdWUiLCJoYXNPd25Qcm9wZXJ0eSIsImNjIiwiYW1vdW50IiwiZm9yRWFjaCIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJub3RlU3RhcnRJbmRleCIsIk1hdGgiLCJtYXgiLCJmaW5kSW5kZXgiLCJub3RlRW5kSW5kZXgiLCJ0cmFjayIsInNsaWNlIiwidHJhY2tFbmNvZGVyIiwiaGVhZGVyIiwidGlja3NQZXJTZWNvbmQiLCJQUFEiLCJicG0iLCJsYXN0RXZlbnRUaW1lIiwiQ0hBTk5FTCIsImdldERlbHRhVGltZSIsInRpY2tzIiwiZmxvb3IiLCJkZWx0YSIsIm5vdGVPbnMiLCJub3RlT24iLCJhZGROb3RlT24iLCJub3RlT2ZmcyIsImFkZE5vdGVPZmYiLCJwdXNoIiwiZmlyc3ROb3RlIiwibGFzdE5vdGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOzs7O0lBRU1BLEs7QUFDTCxrQkFBbUM7QUFBQSxNQUF2QkMsSUFBdUIsdUVBQWxCLEVBQWtCO0FBQUEsTUFBZEMsVUFBYyx1RUFBSCxFQUFHOztBQUFBOztBQUVsQzs7OztBQUlBLE9BQUtELElBQUwsR0FBWUEsSUFBWjs7QUFFQTs7OztBQUlBLE9BQUtFLEtBQUwsR0FBYSxFQUFiOztBQUVBOzs7O0FBSUEsT0FBS0MsY0FBTCxHQUFzQixFQUF0Qjs7QUFFQTs7OztBQUlBLE9BQUtGLFVBQUwsR0FBa0IsRUFBbEI7QUFDQTs7Ozt1QkFFSUcsSSxFQUFNQyxJLEVBQTZCO0FBQUEsT0FBdkJDLFFBQXVCLHVFQUFkLENBQWM7QUFBQSxPQUFYQyxRQUFX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VUFBQ1YsSUFBRCxFQUFVO0FBQzVCa0MsYUFBU0UsSUFBVCxDQUFjO0FBQ2J2QyxXQUFPRyxLQUFLSSxPQURDO0FBRWJSLFdBQU9JLEtBQUtKLElBRkM7QUFHYkosV0FBT1EsS0FBS1I7QUFIQyxLQUFkO0FBS0EsSUFORDtBQU9BLFVBQU8wQyxRQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7c0JBSWE7QUFDWixVQUFPLEtBQUt4QyxLQUFMLENBQVdRLE1BQWxCO0FBQ0E7O0FBRUQ7Ozs7Ozs7c0JBSWdCO0FBQ2YsT0FBSSxLQUFLUixLQUFMLENBQVdRLE1BQWYsRUFBc0I7QUFDckIsUUFBSW1DLFlBQVksS0FBSzNDLEtBQUwsQ0FBVyxDQUFYLENBQWhCO0FBQ0EsV0FBTzJDLFVBQVVMLE1BQWpCO0FBQ0EsSUFIRCxNQUdPO0FBQ04sV0FBTyxDQUFQO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7OztzQkFJZTtBQUNkLE9BQUksS0FBS3RDLEtBQUwsQ0FBV1EsTUFBZixFQUFzQjtBQUNyQixRQUFJb0MsV0FBVyxLQUFLNUMsS0FBTCxDQUFXLEtBQUtBLEtBQUwsQ0FBV1EsTUFBWCxHQUFvQixDQUEvQixDQUFmO0FBQ0EsV0FBT29DLFNBQVNsQyxPQUFoQjtBQUNBLElBSEQsTUFHTztBQUNOLFdBQU8sQ0FBUDtBQUNBO0FBQ0Q7Ozs7OztRQTBETWIsSyxHQUFBQSxLIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge05vdGV9IGZyb20gJy4vTm90ZSdcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJ1xuaW1wb3J0IHtNZXJnZX0gZnJvbSAnLi9NZXJnZSdcbmltcG9ydCB7QmluYXJ5SW5zZXJ0fSBmcm9tICcuL0JpbmFyeUluc2VydCdcblxuY2xhc3MgVHJhY2sge1xuXHRjb25zdHJ1Y3RvcihuYW1lPScnLCBpbnN0cnVtZW50PScnKXtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoZSB0cmFja1xuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0dGhpcy5uYW1lID0gbmFtZVxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG5vdGUgZXZlbnRzXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqL1xuXHRcdHRoaXMubm90ZXMgPSBbXVxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNvbnRyb2wgY2hhbmdlc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5jb250cm9sQ2hhbmdlcyA9IHt9XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdHJhY2tzIGluc3R1cm1lbnQgaWYgb25lIGV4aXN0c1xuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICovXG5cdFx0dGhpcy5pbnN0cnVtZW50ID0gJydcblx0fVxuXG5cdG5vdGUobWlkaSwgdGltZSwgZHVyYXRpb249MCwgdmVsb2NpdHk9MSl7XG5cdFx0Y29uc3Qgbm90ZSA9IG5ldyBOb3RlKG1pZGksIHRpbWUsIGR1cmF0aW9uLCB2ZWxvY2l0eSlcblx0XHRCaW5hcnlJbnNlcnQodGhpcy5ub3Rlcywgbm90ZSlcblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCBhIG5vdGUgb24gZXZlbnRcblx0ICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gbWlkaSAgICAgVGhlIG1pZGkgbm90ZSBhcyBlaXRoZXIgYSBtaWRpIG51bWJlciBvciBcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUGl0Y2ggTm90YXRpb24gbGlrZSAoJ0MjNCcpXG5cdCAqIEBwYXJhbSAge051bWJlcn0gdGltZSAgICAgVGhlIHRpbWUgaW4gc2Vjb25kc1xuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHZlbG9jaXR5IFRoZSB2ZWxvY2l0eSB2YWx1ZSAwLTFcblx0ICogQHJldHVybiB7VHJhY2t9IHRoaXNcblx0ICovXG5cdG5vdGVPbihtaWRpLCB0aW1lLCB2ZWxvY2l0eT0xKXtcblx0XHRjb25zdCBub3RlID0gbmV3IE5vdGUobWlkaSwgdGltZSwgMCwgdmVsb2NpdHkpXHRcdFxuXHRcdEJpbmFyeUluc2VydCh0aGlzLm5vdGVzLCBub3RlKVxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQWRkIGEgbm90ZSBvZmYgZXZlbnQuIEdvIHRocm91Z2ggYW5kIGZpbmQgYW4gdW5yZXNvbHZlZFxuXHQgKiBub3RlT24gZXZlbnQgd2l0aCB0aGUgc2FtZSBwaXRjaC5cblx0ICogQHBhcmFtICB7U3RyaW5nfE51bWJlcn0gbWlkaSBUaGUgbWlkaSBudW1iZXIgb3Igbm90ZSBuYW1lLlxuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWUgVGhlIHRpbWUgb2YgdGhlIGV2ZW50IGluIHNlY29uZHNcblx0ICogQHJldHVybiB7VHJhY2t9IHRoaXNcblx0ICovXG5cdG5vdGVPZmYobWlkaSwgdGltZSl7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5vdGVzLmxlbmd0aDsgaSsrKXtcblx0XHRcdGxldCBub3RlID0gdGhpcy5ub3Rlc1tpXVxuXHRcdFx0aWYgKG5vdGUubWF0Y2gobWlkaSkgJiYgbm90ZS5kdXJhdGlvbiA9PT0gMCl7XG5cdFx0XHRcdG5vdGUubm90ZU9mZiA9IHRpbWVcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQWRkIGEgQ0MgZXZlbnRcblx0ICogQHBhcmFtICB7TnVtYmVyfSBudW0gVGhlIENDIG51bWJlclxuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWUgVGhlIHRpbWUgb2YgdGhlIGV2ZW50IGluIHNlY29uZHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgQ0Ncblx0ICogQHJldHVybiB7VHJhY2t9IHRoaXNcblx0ICovXG5cdGNjKG51bSwgdGltZSwgdmFsdWUpe1xuXHRcdGlmICghdGhpcy5jb250cm9sQ2hhbmdlcy5oYXNPd25Qcm9wZXJ0eShudW0pKXtcblx0XHRcdHRoaXMuY29udHJvbENoYW5nZXNbbnVtXSA9IFtdXG5cdFx0fVxuXHRcdGNvbnN0IGNjID0gbmV3IENvbnRyb2wobnVtLCB0aW1lLCB2YWx1ZSlcblx0XHRCaW5hcnlJbnNlcnQodGhpcy5jb250cm9sQ2hhbmdlc1tudW1dLCBjYylcblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEFuIGFycmF5IG9mIGFsbCB0aGUgbm90ZSBvbiBldmVudHNcblx0ICogQHR5cGUge0FycmF5PE9iamVjdD59XG5cdCAqIEByZWFkT25seVxuXHQgKi9cblx0Z2V0IG5vdGVPbnMoKXtcblx0XHRjb25zdCBub3RlT25zID0gW11cblx0XHR0aGlzLm5vdGVzLmZvckVhY2goKG5vdGUpID0+IHtcblx0XHRcdG5vdGVPbnMucHVzaCh7XG5cdFx0XHRcdHRpbWUgOiBub3RlLm5vdGVPbixcblx0XHRcdFx0bWlkaSA6IG5vdGUubWlkaSxcblx0XHRcdFx0bmFtZSA6IG5vdGUubmFtZSxcblx0XHRcdFx0dmVsb2NpdHkgOiBub3RlLnZlbG9jaXR5XG5cdFx0XHR9KVxuXHRcdH0pXG5cdFx0cmV0dXJuIG5vdGVPbnNcblx0fVxuXG5cdC8qKlxuXHQgKiBBbiBhcnJheSBvZiBhbGwgdGhlIG5vdGVPZmYgZXZlbnRzXG5cdCAqIEB0eXBlIHtBcnJheTxPYmplY3Q+fVxuXHQgKiBAcmVhZE9ubHlcblx0ICovXG5cdGdldCBub3RlT2Zmcygpe1xuXHRcdGNvbnN0IG5vdGVPZmZzID0gW11cblx0XHR0aGlzLm5vdGVzLmZvckVhY2goKG5vdGUpID0+IHtcblx0XHRcdG5vdGVPZmZzLnB1c2goe1xuXHRcdFx0XHR0aW1lIDogbm90ZS5ub3RlT2ZmLFxuXHRcdFx0XHRtaWRpIDogbm90ZS5taWRpLFxuXHRcdFx0XHRuYW1lIDogbm90ZS5uYW1lXG5cdFx0XHR9KVxuXHRcdH0pXG5cdFx0cmV0dXJuIG5vdGVPZmZzXG5cdH1cblxuXHQvKipcblx0ICogVGhlIGxlbmd0aCBpbiBzZWNvbmRzIG9mIHRoZSB0cmFja1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKi9cblx0Z2V0IGxlbmd0aCgpIHtcblx0XHRyZXR1cm4gdGhpcy5ub3Rlcy5sZW5ndGhcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgdGltZSBvZiB0aGUgZmlyc3QgZXZlbnQgaW4gc2Vjb25kc1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKi9cblx0Z2V0IHN0YXJ0VGltZSgpIHtcblx0XHRpZiAodGhpcy5ub3Rlcy5sZW5ndGgpe1xuXHRcdFx0bGV0IGZpcnN0Tm90ZSA9IHRoaXMubm90ZXNbMF1cblx0XHRcdHJldHVybiBmaXJzdE5vdGUubm90ZU9uXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAwXG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSB0aW1lIG9mIHRoZSBsYXN0IGV2ZW50IGluIHNlY29uZHNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICovXG5cdGdldCBkdXJhdGlvbigpIHtcblx0XHRpZiAodGhpcy5ub3Rlcy5sZW5ndGgpe1xuXHRcdFx0bGV0IGxhc3ROb3RlID0gdGhpcy5ub3Rlc1t0aGlzLm5vdGVzLmxlbmd0aCAtIDFdXG5cdFx0XHRyZXR1cm4gbGFzdE5vdGUubm90ZU9mZlxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gMFxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTY2FsZSB0aGUgdGltaW5nIG9mIGFsbCB0aGUgZXZlbnRzIGluIHRoZSB0cmFja1xuXHQgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IFRoZSBhbW91bnQgdG8gc2NhbGUgYWxsIHRoZSB2YWx1ZXNcblx0ICovXG5cdHNjYWxlKGFtb3VudCl7XG5cdFx0dGhpcy5ub3Rlcy5mb3JFYWNoKChub3RlKSA9PiB7XG5cdFx0XHRub3RlLnRpbWUgKj0gYW1vdW50XG5cdFx0XHRub3RlLmR1cmF0aW9uICo9IGFtb3VudFxuXHRcdH0pXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBTbGljZSByZXR1cm5zIGEgbmV3IHRyYWNrIHdpdGggb25seSBldmVudHMgdGhhdCBvY2N1cmVkIGJldHdlZW4gc3RhcnRUaW1lIGFuZCBlbmRUaW1lLiBcblx0ICogTW9kaWZpZXMgdGhpcyB0cmFjay5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0VGltZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZW5kVGltZVxuXHQgKiBAcmV0dXJucyB7VHJhY2t9XG5cdCAqL1xuXHRzbGljZShzdGFydFRpbWU9MCwgZW5kVGltZT10aGlzLmR1cmF0aW9uKXtcblx0XHQvLyBnZXQgdGhlIGluZGV4IGJlZm9yZSB0aGUgc3RhcnRUaW1lXG5cdFx0Y29uc3Qgbm90ZVN0YXJ0SW5kZXggPSBNYXRoLm1heCh0aGlzLm5vdGVzLmZpbmRJbmRleCgobm90ZSkgPT4gbm90ZS50aW1lID49IHN0YXJ0VGltZSksIDApXG5cdFx0Y29uc3Qgbm90ZUVuZEluZGV4ID0gdGhpcy5ub3Rlcy5maW5kSW5kZXgoKG5vdGUpID0+IG5vdGUubm90ZU9mZiA+PSBlbmRUaW1lKSArIDFcblx0XHRjb25zdCB0cmFjayA9IG5ldyBUcmFjayh0aGlzLm5hbWUpXG5cdFx0dHJhY2subm90ZXMgPSB0aGlzLm5vdGVzLnNsaWNlKG5vdGVTdGFydEluZGV4LCBub3RlRW5kSW5kZXgpXG5cdFx0Ly9zaGlmdCB0aGUgc3RhcnQgdGltZVxuXHRcdHRyYWNrLm5vdGVzLmZvckVhY2goKG5vdGUpID0+IG5vdGUudGltZSA9IG5vdGUudGltZSAtIHN0YXJ0VGltZSlcblx0XHRyZXR1cm4gdHJhY2tcblx0fVxuXG5cdC8qKlxuXHQgKiBXcml0ZSB0aGUgb3V0cHV0IHRvIHRoZSBzdHJlYW1cblx0ICovXG5cdGVuY29kZSh0cmFja0VuY29kZXIsIGhlYWRlcil7XG5cblx0XHRjb25zdCB0aWNrc1BlclNlY29uZCA9IGhlYWRlci5QUFEgLyAoNjAgLyBoZWFkZXIuYnBtKVxuXHRcdGxldCBsYXN0RXZlbnRUaW1lID0gMFxuXG5cdFx0Y29uc3QgQ0hBTk5FTCA9IDBcblxuXHRcdGZ1bmN0aW9uIGdldERlbHRhVGltZSh0aW1lKXtcblx0XHRcdGNvbnN0IHRpY2tzID0gTWF0aC5mbG9vcih0aWNrc1BlclNlY29uZCAqIHRpbWUpXG5cdFx0XHRjb25zdCBkZWx0YSA9IE1hdGgubWF4KHRpY2tzIC0gbGFzdEV2ZW50VGltZSwgMClcblx0XHRcdGxhc3RFdmVudFRpbWUgPSB0aWNrc1xuXHRcdFx0cmV0dXJuIGRlbHRhXG5cdFx0fVxuXG5cdFx0TWVyZ2UodGhpcy5ub3RlT25zLCAobm90ZU9uKSA9PiB7XG5cdFx0XHR0cmFja0VuY29kZXIuYWRkTm90ZU9uKENIQU5ORUwsIG5vdGVPbi5uYW1lLCBnZXREZWx0YVRpbWUobm90ZU9uLnRpbWUpLCBNYXRoLmZsb29yKG5vdGVPbi52ZWxvY2l0eSAqIDEyNykpXG5cdFx0fSwgdGhpcy5ub3RlT2ZmcywgKG5vdGVPZmYpID0+IHtcblx0XHRcdHRyYWNrRW5jb2Rlci5hZGROb3RlT2ZmKENIQU5ORUwsIG5vdGVPZmYubmFtZSwgZ2V0RGVsdGFUaW1lKG5vdGVPZmYudGltZSkpXG5cdFx0fSlcblx0fVxuXG59XG5cbmV4cG9ydCB7VHJhY2t9XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1RyYWNrLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.Note = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Util = __webpack_require__(5);\n\nvar _Util2 = _interopRequireDefault(_Util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Note = function () {\n\tfunction Note(midi, time) {\n\t\tvar duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\t\tvar velocity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n\t\t_classCallCheck(this, Note);\n\n\t\t/**\n   * The MIDI note number\n   * @type {Number}\n   */\n\t\tthis.midi;\n\n\t\tif (_Util2.default.isNumber(midi)) {\n\t\t\tthis.midi = midi;\n\t\t} else if (_Util2.default.isPitch(midi)) {\n\t\t\tthis.name = midi;\n\t\t} else {\n\t\t\tthrow new Error('the midi value must either be in Pitch Notation (e.g. C#4) or a midi value');\n\t\t}\n\n\t\t/**\n   * The note on time in seconds\n   * @type {Number}\n   */\n\t\tthis.time = time;\n\n\t\t/**\n   * The duration in seconds\n   * @type {Number}\n   */\n\t\tthis.duration = duration;\n\n\t\t/**\n   * The velocity 0-1\n   * @type {Number}\n   */\n\t\tthis.velocity = velocity;\n\t}\n\n\t/**\n  * If the note is the same as the given note\n  * @param {String|Number} note\n  * @return {Boolean}\n  */\n\n\n\t_createClass(Note, [{\n\t\tkey: 'match',\n\t\tvalue: function match(note) {\n\t\t\tif (_Util2.default.isNumber(note)) {\n\t\t\t\treturn this.midi === note;\n\t\t\t} else if (_Util2.default.isPitch(note)) {\n\t\t\t\treturn this.name.toLowerCase() === note.toLowerCase();\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * The note in Scientific Pitch Notation\n   * @type {String}\n   */\n\n\t}, {\n\t\tkey: 'toJSON',\n\n\n\t\t/**\n   * Convert the note to JSON\n   * @returns {Object}\n   */\n\t\tvalue: function toJSON() {\n\t\t\treturn {\n\t\t\t\tname: this.name,\n\t\t\t\tmidi: this.midi,\n\t\t\t\ttime: this.time,\n\t\t\t\tvelocity: this.velocity,\n\t\t\t\tduration: this.duration\n\t\t\t};\n\t\t}\n\t}, {\n\t\tkey: 'name',\n\t\tget: function get() {\n\t\t\treturn _Util2.default.midiToPitch(this.midi);\n\t\t},\n\t\tset: function set(name) {\n\t\t\tthis.midi = _Util2.default.pitchToMidi(name);\n\t\t}\n\n\t\t/**\n   * Alias for time\n   * @type {Number}\n   */\n\n\t}, {\n\t\tkey: 'noteOn',\n\t\tget: function get() {\n\t\t\treturn this.time;\n\t\t},\n\t\tset: function set(t) {\n\t\t\tthis.time = t;\n\t\t}\n\n\t\t/**\n   * The note off time\n   * @type {Number}\n   */\n\n\t}, {\n\t\tkey: 'noteOff',\n\t\tget: function get() {\n\t\t\treturn this.time + this.duration;\n\t\t},\n\t\tset: function set(time) {\n\t\t\tthis.duration = time - this.time;\n\t\t}\n\t}]);\n\n\treturn Note;\n}();\n\nexports.Note = Note;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvTm90ZS5qcz9iNDAwIl0sIm5hbWVzIjpbIk5vdGUiLCJtaWRpIiwidGltZSIsImR1cmF0aW9uIiwidmVsb2NpdHkiLCJpc051bWJlciIsImlzUGl0Y2giLCJuYW1lIiwiRXJyb3IiLCJub3RlIiwidG9Mb3dlckNhc2UiLCJtaWRpVG9QaXRjaCIsInBpdGNoVG9NaWRpIiwidCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0lBRU1BLEk7QUFDTCxlQUFZQyxJQUFaLEVBQWtCQyxJQUFsQixFQUErQztBQUFBLE1BQXZCQyxRQUF1Qix1RUFBZCxDQUFjO0FBQUEsTUFBWEMsUUFBVyx1RUFBRixDQUFFOztBQUFBOztBQUU5Qzs7OztBQUlBLE9BQUtILElBQUw7O0FBRUEsTUFBSSxlQUFLSSxRQUFMLENBQWNKLElBQWQsQ0FBSixFQUF3QjtBQUN2QixRQUFLQSxJQUFMLEdBQVlBLElBQVo7QUFDQSxHQUZELE1BRU8sSUFBSSxlQUFLSyxPQUFMLENBQWFMLElBQWIsQ0FBSixFQUF1QjtBQUM3QixRQUFLTSxJQUFMLEdBQVlOLElBQVo7QUFDQSxHQUZNLE1BRUE7QUFDTixTQUFNLElBQUlPLEtBQUosQ0FBVSw0RUFBVixDQUFOO0FBQ0E7O0FBRUQ7Ozs7QUFJQSxPQUFLTixJQUFMLEdBQVlBLElBQVo7O0FBRUE7Ozs7QUFJQSxPQUFLQyxRQUFMLEdBQWdCQSxRQUFoQjs7QUFFQTs7OztBQUlBLE9BQUtDLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozt3QkFLTUssSSxFQUFLO0FBQ1YsT0FBSSxlQUFLSixRQUFMLENBQWNJLElBQWQsQ0FBSixFQUF3QjtBQUN2QixXQUFPLEtBQUtSLElBQUwsS0FBY1EsSUFBckI7QUFDQSxJQUZELE1BRU8sSUFBSSxlQUFLSCxPQUFMLENBQWFHLElBQWIsQ0FBSixFQUF1QjtBQUM3QixXQUFPLEtBQUtGLElBQUwsQ0FBVUcsV0FBVixPQUE0QkQsS0FBS0MsV0FBTCxFQUFuQztBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQWlDQTs7OzsyQkFJUTtBQUNQLFVBQU87QUFDTkgsVUFBTyxLQUFLQSxJQUROO0FBRU5OLFVBQU8sS0FBS0EsSUFGTjtBQUdOQyxVQUFPLEtBQUtBLElBSE47QUFJTkUsY0FBVyxLQUFLQSxRQUpWO0FBS05ELGNBQVcsS0FBS0E7QUFMVixJQUFQO0FBT0E7OztzQkF6Q1M7QUFDVCxVQUFPLGVBQUtRLFdBQUwsQ0FBaUIsS0FBS1YsSUFBdEIsQ0FBUDtBQUNBLEc7b0JBQ1FNLEksRUFBSztBQUNiLFFBQUtOLElBQUwsR0FBWSxlQUFLVyxXQUFMLENBQWlCTCxJQUFqQixDQUFaO0FBQ0E7O0FBRUQ7Ozs7Ozs7c0JBSVk7QUFDWCxVQUFPLEtBQUtMLElBQVo7QUFDQSxHO29CQUNVVyxDLEVBQUU7QUFDWixRQUFLWCxJQUFMLEdBQVlXLENBQVo7QUFDQTs7QUFFRDs7Ozs7OztzQkFJYTtBQUNaLFVBQU8sS0FBS1gsSUFBTCxHQUFZLEtBQUtDLFFBQXhCO0FBQ0EsRztvQkFDV0QsSSxFQUFLO0FBQ2hCLFFBQUtDLFFBQUwsR0FBZ0JELE9BQU8sS0FBS0EsSUFBNUI7QUFDQTs7Ozs7O1FBaUJNRixJLEdBQUFBLEkiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBVdGlsIGZyb20gJy4vVXRpbCdcblxuY2xhc3MgTm90ZXtcblx0Y29uc3RydWN0b3IobWlkaSwgdGltZSwgZHVyYXRpb249MCwgdmVsb2NpdHk9MSl7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgTUlESSBub3RlIG51bWJlclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5taWRpO1xuXG5cdFx0aWYgKFV0aWwuaXNOdW1iZXIobWlkaSkpe1xuXHRcdFx0dGhpcy5taWRpID0gbWlkaVxuXHRcdH0gZWxzZSBpZiAoVXRpbC5pc1BpdGNoKG1pZGkpKXtcblx0XHRcdHRoaXMubmFtZSA9IG1pZGlcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCd0aGUgbWlkaSB2YWx1ZSBtdXN0IGVpdGhlciBiZSBpbiBQaXRjaCBOb3RhdGlvbiAoZS5nLiBDIzQpIG9yIGEgbWlkaSB2YWx1ZScpXG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG5vdGUgb24gdGltZSBpbiBzZWNvbmRzXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLnRpbWUgPSB0aW1lXG5cblx0XHQvKipcblx0XHQgKiBUaGUgZHVyYXRpb24gaW4gc2Vjb25kc1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uXG5cblx0XHQvKipcblx0XHQgKiBUaGUgdmVsb2NpdHkgMC0xXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLnZlbG9jaXR5ID0gdmVsb2NpdHlcblx0fVxuXG5cdC8qKlxuXHQgKiBJZiB0aGUgbm90ZSBpcyB0aGUgc2FtZSBhcyB0aGUgZ2l2ZW4gbm90ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IG5vdGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdG1hdGNoKG5vdGUpe1xuXHRcdGlmIChVdGlsLmlzTnVtYmVyKG5vdGUpKXtcblx0XHRcdHJldHVybiB0aGlzLm1pZGkgPT09IG5vdGVcblx0XHR9IGVsc2UgaWYgKFV0aWwuaXNQaXRjaChub3RlKSl7XG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vdGUudG9Mb3dlckNhc2UoKVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgbm90ZSBpbiBTY2llbnRpZmljIFBpdGNoIE5vdGF0aW9uXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXQgbmFtZSgpe1xuXHRcdHJldHVybiBVdGlsLm1pZGlUb1BpdGNoKHRoaXMubWlkaSlcblx0fVxuXHRzZXQgbmFtZShuYW1lKXtcblx0XHR0aGlzLm1pZGkgPSBVdGlsLnBpdGNoVG9NaWRpKG5hbWUpXG5cdH1cblxuXHQvKipcblx0ICogQWxpYXMgZm9yIHRpbWVcblx0ICogQHR5cGUge051bWJlcn1cblx0ICovXG5cdGdldCBub3RlT24oKXtcblx0XHRyZXR1cm4gdGhpcy50aW1lXG5cdH1cblx0c2V0IG5vdGVPbih0KXtcblx0XHR0aGlzLnRpbWUgPSB0XG5cdH1cblxuXHQvKipcblx0ICogVGhlIG5vdGUgb2ZmIHRpbWVcblx0ICogQHR5cGUge051bWJlcn1cblx0ICovXG5cdGdldCBub3RlT2ZmKCl7XG5cdFx0cmV0dXJuIHRoaXMudGltZSArIHRoaXMuZHVyYXRpb25cblx0fVxuXHRzZXQgbm90ZU9mZih0aW1lKXtcblx0XHR0aGlzLmR1cmF0aW9uID0gdGltZSAtIHRoaXMudGltZVxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgdGhlIG5vdGUgdG8gSlNPTlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHQgKi9cblx0dG9KU09OKCl7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG5hbWUgOiB0aGlzLm5hbWUsXG5cdFx0XHRtaWRpIDogdGhpcy5taWRpLFxuXHRcdFx0dGltZSA6IHRoaXMudGltZSxcblx0XHRcdHZlbG9jaXR5IDogdGhpcy52ZWxvY2l0eSxcblx0XHRcdGR1cmF0aW9uIDogdGhpcy5kdXJhdGlvblxuXHRcdH1cblx0fVxufVxuXG5leHBvcnQge05vdGV9XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL05vdGUuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 8 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar channelNames = {\n\t\"1\": \"modulationWheel\",\n\t\"2\": \"breath\",\n\t\"4\": \"footController\",\n\t\"5\": \"portamentoTime\",\n\t\"7\": \"volume\",\n\t\"8\": \"balance\",\n\t\"10\": \"pan\",\n\t\"64\": \"sustain\",\n\t\"65\": \"portamentoTime\",\n\t\"66\": \"sostenuto\",\n\t\"67\": \"softPedal\",\n\t\"68\": \"legatoFootswitch\",\n\t\"84\": \"portamentoContro\"\n};\n\nvar Control = function () {\n\tfunction Control(number, time, value) {\n\t\t_classCallCheck(this, Control);\n\n\t\tthis.number = number;\n\n\t\tthis.time = time;\n\n\t\tthis.value = value;\n\t}\n\n\t/**\n  * The common name of the control change event\n  * @type {String}\n  * @readOnly\n  */\n\n\n\t_createClass(Control, [{\n\t\tkey: \"name\",\n\t\tget: function get() {\n\t\t\tif (channelNames.hasOwnProperty(this.number)) {\n\t\t\t\treturn channelNames[this.number];\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn Control;\n}();\n\nexports.Control = Control;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29udHJvbC5qcz8yYzllIl0sIm5hbWVzIjpbImNoYW5uZWxOYW1lcyIsIkNvbnRyb2wiLCJudW1iZXIiLCJ0aW1lIiwidmFsdWUiLCJoYXNPd25Qcm9wZXJ0eSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLElBQU1BLGVBQWU7QUFDcEIsTUFBTyxpQkFEYTtBQUVwQixNQUFPLFFBRmE7QUFHcEIsTUFBTyxnQkFIYTtBQUlwQixNQUFPLGdCQUphO0FBS3BCLE1BQU8sUUFMYTtBQU1wQixNQUFPLFNBTmE7QUFPcEIsT0FBTyxLQVBhO0FBUXBCLE9BQU8sU0FSYTtBQVNwQixPQUFPLGdCQVRhO0FBVXBCLE9BQU8sV0FWYTtBQVdwQixPQUFPLFdBWGE7QUFZcEIsT0FBTyxrQkFaYTtBQWFwQixPQUFPO0FBYmEsQ0FBckI7O0lBZ0JNQyxPO0FBQ0wsa0JBQVlDLE1BQVosRUFBb0JDLElBQXBCLEVBQTBCQyxLQUExQixFQUFnQztBQUFBOztBQUUvQixPQUFLRixNQUFMLEdBQWNBLE1BQWQ7O0FBRUEsT0FBS0MsSUFBTCxHQUFZQSxJQUFaOztBQUVBLE9BQUtDLEtBQUwsR0FBYUEsS0FBYjtBQUNBOztBQUVEOzs7Ozs7Ozs7c0JBS1U7QUFDVCxPQUFJSixhQUFhSyxjQUFiLENBQTRCLEtBQUtILE1BQWpDLENBQUosRUFBNkM7QUFDNUMsV0FBT0YsYUFBYSxLQUFLRSxNQUFsQixDQUFQO0FBQ0E7QUFDRDs7Ozs7O1FBR01ELE8sR0FBQUEsTyIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY2hhbm5lbE5hbWVzID0ge1xuXHRcIjFcIiAgOiBcIm1vZHVsYXRpb25XaGVlbFwiLFxuXHRcIjJcIiAgOiBcImJyZWF0aFwiLFxuXHRcIjRcIiAgOiBcImZvb3RDb250cm9sbGVyXCIsXG5cdFwiNVwiICA6IFwicG9ydGFtZW50b1RpbWVcIixcblx0XCI3XCIgIDogXCJ2b2x1bWVcIixcblx0XCI4XCIgIDogXCJiYWxhbmNlXCIsXG5cdFwiMTBcIiA6IFwicGFuXCIsXG5cdFwiNjRcIiA6IFwic3VzdGFpblwiLFxuXHRcIjY1XCIgOiBcInBvcnRhbWVudG9UaW1lXCIsXG5cdFwiNjZcIiA6IFwic29zdGVudXRvXCIsXG5cdFwiNjdcIiA6IFwic29mdFBlZGFsXCIsXG5cdFwiNjhcIiA6IFwibGVnYXRvRm9vdHN3aXRjaFwiLFxuXHRcIjg0XCIgOiBcInBvcnRhbWVudG9Db250cm9cIlxufVxuXG5jbGFzcyBDb250cm9se1xuXHRjb25zdHJ1Y3RvcihudW1iZXIsIHRpbWUsIHZhbHVlKXtcblxuXHRcdHRoaXMubnVtYmVyID0gbnVtYmVyXG5cblx0XHR0aGlzLnRpbWUgPSB0aW1lXG5cblx0XHR0aGlzLnZhbHVlID0gdmFsdWVcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgY29tbW9uIG5hbWUgb2YgdGhlIGNvbnRyb2wgY2hhbmdlIGV2ZW50XG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEByZWFkT25seVxuXHQgKi9cblx0Z2V0IG5hbWUoKXtcblx0XHRpZiAoY2hhbm5lbE5hbWVzLmhhc093blByb3BlcnR5KHRoaXMubnVtYmVyKSl7XG5cdFx0XHRyZXR1cm4gY2hhbm5lbE5hbWVzW3RoaXMubnVtYmVyXVxuXHRcdH1cblx0fVxufVxuXG5leHBvcnQge0NvbnRyb2x9XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0NvbnRyb2wuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 9 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nfunction hasMoreValues(arrays, positions) {\n\tfor (var i = 0; i < arrays.length; i++) {\n\t\tvar arr = arrays[i];\n\t\tvar pos = positions[i];\n\t\tif (arr.length > pos) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction getLowestAtPosition(arrays, positions, encoders) {\n\tvar lowestIndex = 0;\n\tvar lowestValue = Infinity;\n\tfor (var i = 0; i < arrays.length; i++) {\n\t\tvar arr = arrays[i];\n\t\tvar pos = positions[i];\n\t\tif (arr[pos] && arr[pos].time < lowestValue) {\n\t\t\tlowestIndex = i;\n\t\t\tlowestValue = arr[pos].time;\n\t\t}\n\t}\n\tencoders[lowestIndex](arrays[lowestIndex][positions[lowestIndex]]);\n\t// increment array\n\tpositions[lowestIndex] += 1;\n}\n\n/**\n * Combine multiple arrays keeping the timing in order\n * The arguments should alternate between the array and the encoder callback\n * @param {...Array|Function} args\n */\nfunction Merge() {\n\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\targs[_key] = arguments[_key];\n\t}\n\n\tvar arrays = args.filter(function (v, i) {\n\t\treturn i % 2 === 0;\n\t});\n\tvar positions = new Uint32Array(arrays.length);\n\tvar encoders = args.filter(function (v, i) {\n\t\treturn i % 2 === 1;\n\t});\n\tvar output = [];\n\twhile (hasMoreValues(arrays, positions)) {\n\t\tgetLowestAtPosition(arrays, positions, encoders);\n\t}\n}\n\nexports.Merge = Merge;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvTWVyZ2UuanM/Yzc4NiJdLCJuYW1lcyI6WyJoYXNNb3JlVmFsdWVzIiwiYXJyYXlzIiwicG9zaXRpb25zIiwiaSIsImxlbmd0aCIsImFyciIsInBvcyIsImdldExvd2VzdEF0UG9zaXRpb24iLCJlbmNvZGVycyIsImxvd2VzdEluZGV4IiwibG93ZXN0VmFsdWUiLCJJbmZpbml0eSIsInRpbWUiLCJNZXJnZSIsImFyZ3MiLCJmaWx0ZXIiLCJ2IiwiVWludDMyQXJyYXkiLCJvdXRwdXQiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLFNBQVNBLGFBQVQsQ0FBdUJDLE1BQXZCLEVBQStCQyxTQUEvQixFQUF5QztBQUN4QyxNQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUYsT0FBT0csTUFBM0IsRUFBbUNELEdBQW5DLEVBQXVDO0FBQ3RDLE1BQUlFLE1BQU1KLE9BQU9FLENBQVAsQ0FBVjtBQUNBLE1BQUlHLE1BQU1KLFVBQVVDLENBQVYsQ0FBVjtBQUNBLE1BQUlFLElBQUlELE1BQUosR0FBYUUsR0FBakIsRUFBcUI7QUFDcEIsVUFBTyxJQUFQO0FBQ0E7QUFDRDtBQUNELFFBQU8sS0FBUDtBQUNBOztBQUVELFNBQVNDLG1CQUFULENBQTZCTixNQUE3QixFQUFxQ0MsU0FBckMsRUFBZ0RNLFFBQWhELEVBQXlEO0FBQ3hELEtBQUlDLGNBQWMsQ0FBbEI7QUFDQSxLQUFJQyxjQUFjQyxRQUFsQjtBQUNBLE1BQUssSUFBSVIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJRixPQUFPRyxNQUEzQixFQUFtQ0QsR0FBbkMsRUFBdUM7QUFDdEMsTUFBSUUsTUFBTUosT0FBT0UsQ0FBUCxDQUFWO0FBQ0EsTUFBSUcsTUFBTUosVUFBVUMsQ0FBVixDQUFWO0FBQ0EsTUFBSUUsSUFBSUMsR0FBSixLQUFhRCxJQUFJQyxHQUFKLEVBQVNNLElBQVQsR0FBZ0JGLFdBQWpDLEVBQThDO0FBQzdDRCxpQkFBY04sQ0FBZDtBQUNBTyxpQkFBY0wsSUFBSUMsR0FBSixFQUFTTSxJQUF2QjtBQUNBO0FBQ0Q7QUFDREosVUFBU0MsV0FBVCxFQUFzQlIsT0FBT1EsV0FBUCxFQUFvQlAsVUFBVU8sV0FBVixDQUFwQixDQUF0QjtBQUNBO0FBQ0FQLFdBQVVPLFdBQVYsS0FBMEIsQ0FBMUI7QUFDQTs7QUFFRDs7Ozs7QUFLQSxTQUFTSSxLQUFULEdBQXVCO0FBQUEsbUNBQUxDLElBQUs7QUFBTEEsTUFBSztBQUFBOztBQUN0QixLQUFNYixTQUFTYSxLQUFLQyxNQUFMLENBQVksVUFBQ0MsQ0FBRCxFQUFJYixDQUFKO0FBQUEsU0FBV0EsSUFBSSxDQUFMLEtBQVksQ0FBdEI7QUFBQSxFQUFaLENBQWY7QUFDQSxLQUFNRCxZQUFZLElBQUllLFdBQUosQ0FBZ0JoQixPQUFPRyxNQUF2QixDQUFsQjtBQUNBLEtBQU1JLFdBQVdNLEtBQUtDLE1BQUwsQ0FBWSxVQUFDQyxDQUFELEVBQUliLENBQUo7QUFBQSxTQUFXQSxJQUFJLENBQUwsS0FBWSxDQUF0QjtBQUFBLEVBQVosQ0FBakI7QUFDQSxLQUFNZSxTQUFTLEVBQWY7QUFDQSxRQUFNbEIsY0FBY0MsTUFBZCxFQUFzQkMsU0FBdEIsQ0FBTixFQUF1QztBQUN0Q0ssc0JBQW9CTixNQUFwQixFQUE0QkMsU0FBNUIsRUFBdUNNLFFBQXZDO0FBQ0E7QUFDRDs7UUFFT0ssSyxHQUFBQSxLIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmZ1bmN0aW9uIGhhc01vcmVWYWx1ZXMoYXJyYXlzLCBwb3NpdGlvbnMpe1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKyl7XG5cdFx0bGV0IGFyciA9IGFycmF5c1tpXVxuXHRcdGxldCBwb3MgPSBwb3NpdGlvbnNbaV1cblx0XHRpZiAoYXJyLmxlbmd0aCA+IHBvcyl7XG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gZ2V0TG93ZXN0QXRQb3NpdGlvbihhcnJheXMsIHBvc2l0aW9ucywgZW5jb2RlcnMpe1xuXHRsZXQgbG93ZXN0SW5kZXggPSAwXG5cdGxldCBsb3dlc3RWYWx1ZSA9IEluZmluaXR5XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKXtcblx0XHRsZXQgYXJyID0gYXJyYXlzW2ldXG5cdFx0bGV0IHBvcyA9IHBvc2l0aW9uc1tpXVxuXHRcdGlmIChhcnJbcG9zXSAmJiAoYXJyW3Bvc10udGltZSA8IGxvd2VzdFZhbHVlKSl7XG5cdFx0XHRsb3dlc3RJbmRleCA9IGlcblx0XHRcdGxvd2VzdFZhbHVlID0gYXJyW3Bvc10udGltZVxuXHRcdH1cblx0fVxuXHRlbmNvZGVyc1tsb3dlc3RJbmRleF0oYXJyYXlzW2xvd2VzdEluZGV4XVtwb3NpdGlvbnNbbG93ZXN0SW5kZXhdXSlcblx0Ly8gaW5jcmVtZW50IGFycmF5XG5cdHBvc2l0aW9uc1tsb3dlc3RJbmRleF0gKz0gMVxufVxuXG4vKipcbiAqIENvbWJpbmUgbXVsdGlwbGUgYXJyYXlzIGtlZXBpbmcgdGhlIHRpbWluZyBpbiBvcmRlclxuICogVGhlIGFyZ3VtZW50cyBzaG91bGQgYWx0ZXJuYXRlIGJldHdlZW4gdGhlIGFycmF5IGFuZCB0aGUgZW5jb2RlciBjYWxsYmFja1xuICogQHBhcmFtIHsuLi5BcnJheXxGdW5jdGlvbn0gYXJnc1xuICovXG5mdW5jdGlvbiBNZXJnZSguLi5hcmdzKXtcblx0Y29uc3QgYXJyYXlzID0gYXJncy5maWx0ZXIoKHYsIGkpID0+IChpICUgMikgPT09IDApXG5cdGNvbnN0IHBvc2l0aW9ucyA9IG5ldyBVaW50MzJBcnJheShhcnJheXMubGVuZ3RoKVxuXHRjb25zdCBlbmNvZGVycyA9IGFyZ3MuZmlsdGVyKCh2LCBpKSA9PiAoaSAlIDIpID09PSAxKVxuXHRjb25zdCBvdXRwdXQgPSBbXVxuXHR3aGlsZShoYXNNb3JlVmFsdWVzKGFycmF5cywgcG9zaXRpb25zKSl7XG5cdFx0Z2V0TG93ZXN0QXRQb3NpdGlvbihhcnJheXMsIHBvc2l0aW9ucywgZW5jb2RlcnMpXG5cdH1cbn1cblxuZXhwb3J0IHtNZXJnZX1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvTWVyZ2UuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 10 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * Return the index of the element at or before the given time\n */\nfunction findElement(array, time) {\n\tvar beginning = 0;\n\tvar len = array.length;\n\tvar end = len;\n\tif (len > 0 && array[len - 1].time <= time) {\n\t\treturn len - 1;\n\t}\n\twhile (beginning < end) {\n\t\t// calculate the midpoint for roughly equal partition\n\t\tvar midPoint = Math.floor(beginning + (end - beginning) / 2);\n\t\tvar event = array[midPoint];\n\t\tvar nextEvent = array[midPoint + 1];\n\t\tif (event.time === time) {\n\t\t\t//choose the last one that has the same time\n\t\t\tfor (var i = midPoint; i < array.length; i++) {\n\t\t\t\tvar testEvent = array[i];\n\t\t\t\tif (testEvent.time === time) {\n\t\t\t\t\tmidPoint = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn midPoint;\n\t\t} else if (event.time < time && nextEvent.time > time) {\n\t\t\treturn midPoint;\n\t\t} else if (event.time > time) {\n\t\t\t//search lower\n\t\t\tend = midPoint;\n\t\t} else if (event.time < time) {\n\t\t\t//search upper\n\t\t\tbeginning = midPoint + 1;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * Does a binary search to insert the note\n * in the correct spot in the array\n * @param  {Array} array\n * @param  {Object} event\n * @param  {Number=} offset\n */\nfunction BinaryInsert(array, event) {\n\tif (array.length) {\n\t\tvar index = findElement(array, event.time);\n\t\tarray.splice(index + 1, 0, event);\n\t} else {\n\t\tarray.push(event);\n\t}\n}\n\nexports.BinaryInsert = BinaryInsert;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQmluYXJ5SW5zZXJ0LmpzP2MyMTkiXSwibmFtZXMiOlsiZmluZEVsZW1lbnQiLCJhcnJheSIsInRpbWUiLCJiZWdpbm5pbmciLCJsZW4iLCJsZW5ndGgiLCJlbmQiLCJtaWRQb2ludCIsIk1hdGgiLCJmbG9vciIsImV2ZW50IiwibmV4dEV2ZW50IiwiaSIsInRlc3RFdmVudCIsIkJpbmFyeUluc2VydCIsImluZGV4Iiwic3BsaWNlIiwicHVzaCJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7O0FBR0EsU0FBU0EsV0FBVCxDQUFxQkMsS0FBckIsRUFBNEJDLElBQTVCLEVBQWtDO0FBQ2pDLEtBQUlDLFlBQVksQ0FBaEI7QUFDQSxLQUFNQyxNQUFNSCxNQUFNSSxNQUFsQjtBQUNBLEtBQUlDLE1BQU1GLEdBQVY7QUFDQSxLQUFJQSxNQUFNLENBQU4sSUFBV0gsTUFBTUcsTUFBTSxDQUFaLEVBQWVGLElBQWYsSUFBdUJBLElBQXRDLEVBQTJDO0FBQzFDLFNBQU9FLE1BQU0sQ0FBYjtBQUNBO0FBQ0QsUUFBT0QsWUFBWUcsR0FBbkIsRUFBdUI7QUFDdEI7QUFDQSxNQUFJQyxXQUFXQyxLQUFLQyxLQUFMLENBQVdOLFlBQVksQ0FBQ0csTUFBTUgsU0FBUCxJQUFvQixDQUEzQyxDQUFmO0FBQ0EsTUFBTU8sUUFBUVQsTUFBTU0sUUFBTixDQUFkO0FBQ0EsTUFBTUksWUFBWVYsTUFBTU0sV0FBVyxDQUFqQixDQUFsQjtBQUNBLE1BQUlHLE1BQU1SLElBQU4sS0FBZUEsSUFBbkIsRUFBd0I7QUFDdkI7QUFDQSxRQUFLLElBQUlVLElBQUlMLFFBQWIsRUFBdUJLLElBQUlYLE1BQU1JLE1BQWpDLEVBQXlDTyxHQUF6QyxFQUE2QztBQUM1QyxRQUFJQyxZQUFZWixNQUFNVyxDQUFOLENBQWhCO0FBQ0EsUUFBSUMsVUFBVVgsSUFBVixLQUFtQkEsSUFBdkIsRUFBNEI7QUFDM0JLLGdCQUFXSyxDQUFYO0FBQ0E7QUFDRDtBQUNELFVBQU9MLFFBQVA7QUFDQSxHQVRELE1BU08sSUFBSUcsTUFBTVIsSUFBTixHQUFhQSxJQUFiLElBQXFCUyxVQUFVVCxJQUFWLEdBQWlCQSxJQUExQyxFQUErQztBQUNyRCxVQUFPSyxRQUFQO0FBQ0EsR0FGTSxNQUVBLElBQUlHLE1BQU1SLElBQU4sR0FBYUEsSUFBakIsRUFBc0I7QUFDNUI7QUFDQUksU0FBTUMsUUFBTjtBQUNBLEdBSE0sTUFHQSxJQUFJRyxNQUFNUixJQUFOLEdBQWFBLElBQWpCLEVBQXNCO0FBQzVCO0FBQ0FDLGVBQVlJLFdBQVcsQ0FBdkI7QUFDQTtBQUNEO0FBQ0QsUUFBTyxDQUFDLENBQVI7QUFDQTs7QUFFRDs7Ozs7OztBQU9BLFNBQVNPLFlBQVQsQ0FBc0JiLEtBQXRCLEVBQTZCUyxLQUE3QixFQUFtQztBQUNsQyxLQUFJVCxNQUFNSSxNQUFWLEVBQWlCO0FBQ2hCLE1BQU1VLFFBQVFmLFlBQVlDLEtBQVosRUFBbUJTLE1BQU1SLElBQXpCLENBQWQ7QUFDQUQsUUFBTWUsTUFBTixDQUFhRCxRQUFRLENBQXJCLEVBQXdCLENBQXhCLEVBQTJCTCxLQUEzQjtBQUNBLEVBSEQsTUFHTztBQUNOVCxRQUFNZ0IsSUFBTixDQUFXUCxLQUFYO0FBQ0E7QUFDRDs7UUFFT0ksWSxHQUFBQSxZIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IGF0IG9yIGJlZm9yZSB0aGUgZ2l2ZW4gdGltZVxuICovXG5mdW5jdGlvbiBmaW5kRWxlbWVudChhcnJheSwgdGltZSkge1xuXHRsZXQgYmVnaW5uaW5nID0gMFxuXHRjb25zdCBsZW4gPSBhcnJheS5sZW5ndGhcblx0bGV0IGVuZCA9IGxlblxuXHRpZiAobGVuID4gMCAmJiBhcnJheVtsZW4gLSAxXS50aW1lIDw9IHRpbWUpe1xuXHRcdHJldHVybiBsZW4gLSAxXG5cdH1cblx0d2hpbGUgKGJlZ2lubmluZyA8IGVuZCl7XG5cdFx0Ly8gY2FsY3VsYXRlIHRoZSBtaWRwb2ludCBmb3Igcm91Z2hseSBlcXVhbCBwYXJ0aXRpb25cblx0XHRsZXQgbWlkUG9pbnQgPSBNYXRoLmZsb29yKGJlZ2lubmluZyArIChlbmQgLSBiZWdpbm5pbmcpIC8gMilcblx0XHRjb25zdCBldmVudCA9IGFycmF5W21pZFBvaW50XVxuXHRcdGNvbnN0IG5leHRFdmVudCA9IGFycmF5W21pZFBvaW50ICsgMV1cblx0XHRpZiAoZXZlbnQudGltZSA9PT0gdGltZSl7XG5cdFx0XHQvL2Nob29zZSB0aGUgbGFzdCBvbmUgdGhhdCBoYXMgdGhlIHNhbWUgdGltZVxuXHRcdFx0Zm9yIChsZXQgaSA9IG1pZFBvaW50OyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRsZXQgdGVzdEV2ZW50ID0gYXJyYXlbaV1cblx0XHRcdFx0aWYgKHRlc3RFdmVudC50aW1lID09PSB0aW1lKXtcblx0XHRcdFx0XHRtaWRQb2ludCA9IGlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1pZFBvaW50XG5cdFx0fSBlbHNlIGlmIChldmVudC50aW1lIDwgdGltZSAmJiBuZXh0RXZlbnQudGltZSA+IHRpbWUpe1xuXHRcdFx0cmV0dXJuIG1pZFBvaW50XG5cdFx0fSBlbHNlIGlmIChldmVudC50aW1lID4gdGltZSl7XG5cdFx0XHQvL3NlYXJjaCBsb3dlclxuXHRcdFx0ZW5kID0gbWlkUG9pbnRcblx0XHR9IGVsc2UgaWYgKGV2ZW50LnRpbWUgPCB0aW1lKXtcblx0XHRcdC8vc2VhcmNoIHVwcGVyXG5cdFx0XHRiZWdpbm5pbmcgPSBtaWRQb2ludCArIDFcblx0XHR9IFxuXHR9XG5cdHJldHVybiAtMVxufVxuXG4vKipcbiAqIERvZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGluc2VydCB0aGUgbm90ZVxuICogaW4gdGhlIGNvcnJlY3Qgc3BvdCBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSAge0FycmF5fSBhcnJheVxuICogQHBhcmFtICB7T2JqZWN0fSBldmVudFxuICogQHBhcmFtICB7TnVtYmVyPX0gb2Zmc2V0XG4gKi9cbmZ1bmN0aW9uIEJpbmFyeUluc2VydChhcnJheSwgZXZlbnQpe1xuXHRpZiAoYXJyYXkubGVuZ3RoKXtcblx0XHRjb25zdCBpbmRleCA9IGZpbmRFbGVtZW50KGFycmF5LCBldmVudC50aW1lKVxuXHRcdGFycmF5LnNwbGljZShpbmRleCArIDEsIDAsIGV2ZW50KVxuXHR9IGVsc2Uge1xuXHRcdGFycmF5LnB1c2goZXZlbnQpXG5cdH1cbn1cblxuZXhwb3J0IHtCaW5hcnlJbnNlcnR9XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0JpbmFyeUluc2VydC5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 11 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n *  Parse tempo and time signature from the midiJson\n *  @param  {Object}  midiJson \n *  @return  {Object}\n */\nfunction parseHeader(midiJson) {\n\tvar ret = {\n\t\tPPQ: midiJson.header.ticksPerBeat\n\t};\n\tfor (var i = 0; i < midiJson.tracks.length; i++) {\n\t\tvar track = midiJson.tracks[i];\n\t\tfor (var j = 0; j < track.length; j++) {\n\t\t\tvar datum = track[j];\n\t\t\tif (datum.type === \"meta\") {\n\t\t\t\tif (datum.subtype === \"timeSignature\") {\n\t\t\t\t\tret.timeSignature = [datum.numerator, datum.denominator];\n\t\t\t\t} else if (datum.subtype === \"setTempo\") {\n\t\t\t\t\tif (!ret.bpm) {\n\t\t\t\t\t\tret.bpm = 60000000 / datum.microsecondsPerBeat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tret.bpm = ret.bpm || 120;\n\treturn ret;\n}\n\nexports.parseHeader = parseHeader;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvSGVhZGVyLmpzP2RhZTYiXSwibmFtZXMiOlsicGFyc2VIZWFkZXIiLCJtaWRpSnNvbiIsInJldCIsIlBQUSIsImhlYWRlciIsInRpY2tzUGVyQmVhdCIsImkiLCJ0cmFja3MiLCJsZW5ndGgiLCJ0cmFjayIsImoiLCJkYXR1bSIsInR5cGUiLCJzdWJ0eXBlIiwidGltZVNpZ25hdHVyZSIsIm51bWVyYXRvciIsImRlbm9taW5hdG9yIiwiYnBtIiwibWljcm9zZWNvbmRzUGVyQmVhdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Ozs7QUFLQSxTQUFTQSxXQUFULENBQXFCQyxRQUFyQixFQUE4QjtBQUM3QixLQUFJQyxNQUFNO0FBQ1RDLE9BQU1GLFNBQVNHLE1BQVQsQ0FBZ0JDO0FBRGIsRUFBVjtBQUdBLE1BQUssSUFBSUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJTCxTQUFTTSxNQUFULENBQWdCQyxNQUFwQyxFQUE0Q0YsR0FBNUMsRUFBZ0Q7QUFDL0MsTUFBSUcsUUFBUVIsU0FBU00sTUFBVCxDQUFnQkQsQ0FBaEIsQ0FBWjtBQUNBLE9BQUssSUFBSUksSUFBSSxDQUFiLEVBQWdCQSxJQUFJRCxNQUFNRCxNQUExQixFQUFrQ0UsR0FBbEMsRUFBc0M7QUFDckMsT0FBSUMsUUFBUUYsTUFBTUMsQ0FBTixDQUFaO0FBQ0EsT0FBSUMsTUFBTUMsSUFBTixLQUFlLE1BQW5CLEVBQTBCO0FBQ3pCLFFBQUlELE1BQU1FLE9BQU4sS0FBa0IsZUFBdEIsRUFBc0M7QUFDckNYLFNBQUlZLGFBQUosR0FBb0IsQ0FBQ0gsTUFBTUksU0FBUCxFQUFrQkosTUFBTUssV0FBeEIsQ0FBcEI7QUFDQSxLQUZELE1BRU8sSUFBSUwsTUFBTUUsT0FBTixLQUFrQixVQUF0QixFQUFpQztBQUN2QyxTQUFJLENBQUNYLElBQUllLEdBQVQsRUFBYTtBQUNaZixVQUFJZSxHQUFKLEdBQVUsV0FBV04sTUFBTU8sbUJBQTNCO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7QUFDRDtBQUNEaEIsS0FBSWUsR0FBSixHQUFVZixJQUFJZSxHQUFKLElBQVcsR0FBckI7QUFDQSxRQUFPZixHQUFQO0FBQ0E7O1FBRU9GLFcsR0FBQUEsVyIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFBhcnNlIHRlbXBvIGFuZCB0aW1lIHNpZ25hdHVyZSBmcm9tIHRoZSBtaWRpSnNvblxuICogIEBwYXJhbSAge09iamVjdH0gIG1pZGlKc29uIFxuICogIEByZXR1cm4gIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKG1pZGlKc29uKXtcblx0dmFyIHJldCA9IHtcblx0XHRQUFEgOiBtaWRpSnNvbi5oZWFkZXIudGlja3NQZXJCZWF0XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtaWRpSnNvbi50cmFja3MubGVuZ3RoOyBpKyspe1xuXHRcdHZhciB0cmFjayA9IG1pZGlKc29uLnRyYWNrc1tpXVxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgdHJhY2subGVuZ3RoOyBqKyspe1xuXHRcdFx0dmFyIGRhdHVtID0gdHJhY2tbal1cblx0XHRcdGlmIChkYXR1bS50eXBlID09PSBcIm1ldGFcIil7XG5cdFx0XHRcdGlmIChkYXR1bS5zdWJ0eXBlID09PSBcInRpbWVTaWduYXR1cmVcIil7XG5cdFx0XHRcdFx0cmV0LnRpbWVTaWduYXR1cmUgPSBbZGF0dW0ubnVtZXJhdG9yLCBkYXR1bS5kZW5vbWluYXRvcl1cblx0XHRcdFx0fSBlbHNlIGlmIChkYXR1bS5zdWJ0eXBlID09PSBcInNldFRlbXBvXCIpe1xuXHRcdFx0XHRcdGlmICghcmV0LmJwbSl7XG5cdFx0XHRcdFx0XHRyZXQuYnBtID0gNjAwMDAwMDAgLyBkYXR1bS5taWNyb3NlY29uZHNQZXJCZWF0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IFxuXHRcdH1cblx0fVxuXHRyZXQuYnBtID0gcmV0LmJwbSB8fCAxMjBcblx0cmV0dXJuIHJldFxufVxuXG5leHBvcnQge3BhcnNlSGVhZGVyfVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9IZWFkZXIuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;